{"id":"osquery-rust-03d","content_hash":"08c360e0eb84e99325ef0772c7b796e1e2e7d27404b8ebc77dfcf47896db3537","title":"Epic: Increase Test Coverage to 95%","description":"","design":"## Requirements (IMMUTABLE)\n- Line coverage reaches 95% (excluding auto-generated _osquery code)\n- All new tests are inline #[cfg(test)] modules (not separate tests/ directory)\n- No unwrap/expect/panic in test code (follow existing clippy rules)\n- Tests run without real osquery (unit tests only, integration deferred to Docker)\n- Signal handling tests are OUT OF SCOPE (complex, platform-specific)\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] util.rs ok_or_thrift_err() both paths tested (Some/None)\n- [ ] Plugin::config() factory and all 6 dispatch methods tested\n- [ ] Plugin::logger() factory and all 6 dispatch methods tested\n- [ ] server.rs cleanup_socket() all paths tested\n- [ ] server.rs notify_plugins_shutdown() tested (single, multiple, panic)\n- [ ] server.rs join_listener_thread() success/timeout paths tested\n- [ ] server.rs wake_listener() tested\n- [ ] Line coverage \u003e= 95% (cargo llvm-cov --ignore-filename-regex _osquery)\n- [ ] All tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO tests in separate tests/ directory (consistency: inline #[cfg(test)] per CLAUDE.md)\n- ❌ NO unwrap/expect/panic in test code (clippy: project forbids these)\n- ❌ NO signal handling tests (complexity: platform-specific, deferred)\n- ❌ NO ThriftClient unit tests (architecture: use mocks, real I/O in Docker later)\n- ❌ NO lowering 95% target without measuring actual coverage first\n\n## Approach\nThree-phase implementation focusing on testable code paths:\n\nPhase 1 - Quick Wins (~2-3 hours):\n- util.rs: Add 2 tests for Option trait extension\n- plugin/_enums/plugin.rs: Add Config/Logger dispatch tests (12+ tests)\n\nPhase 2 - Server Infrastructure (~6-8 hours):\n- Socket cleanup tests with tempfile\n- Plugin shutdown tests with mock plugins\n- Thread management tests with configurable timeouts\n\nPhase 3 - Measurement:\n- Measure coverage after each phase\n- Adjust strategy based on actual numbers\n\n## Architecture\n- util.rs: Simple trait tests\n- plugin/_enums/plugin.rs: TestConfigPlugin, TestLoggerPlugin mocks\n- server.rs: Extend existing MockOsqueryClient usage, add tempfile for sockets\n\n## Design Rationale\n### Problem\nCurrent coverage is 76.19% (excluding auto-gen). Target is 95%.\nMain gaps: server.rs (37%), plugin enum (25%), client.rs (14%), util.rs (45%)\n\n### Research Findings\n**Codebase:**\n- server.rs:400-413 - cleanup_socket() completely untested\n- server.rs:386-395 - notify_plugins_shutdown() untested\n- server.rs:241-268 - join_listener_thread() timeout logic untested\n- plugin/_enums/plugin.rs:26-32 - Config/Logger factories untested\n- util.rs:14-19 - None path untested\n\n**External:**\n- Tokio testing guide: Use trait abstraction + io::Builder for mock I/O\n- Signal handling: Complex, platform-specific, recommend deferring\n- Thrift testing: No specialized framework, use trait mocks\n\n### Approaches Considered\n1. **Phased approach with measurement** ✓\n   - Pros: Pragmatic, adjusts based on reality\n   - Cons: May not hit exact 95%\n   - **Chosen because:** Skip signal handling, measure actual impact\n\n2. **Full coverage including signals**\n   - Pros: Complete coverage\n   - Cons: Complex platform-specific tests, high effort\n   - **Rejected because:** User prefers to skip signal tests\n\n3. **Unit test ThriftClient**\n   - Pros: Higher client.rs coverage\n   - Cons: Requires real socket I/O, defeats purpose\n   - **Rejected because:** Integration tests in Docker are better fit\n\n### Scope Boundaries\n**In scope:**\n- util.rs tests\n- plugin enum dispatch tests\n- server.rs infrastructure tests (socket, shutdown, thread)\n- Measurement after each phase\n\n**Out of scope (deferred/never):**\n- Signal handling tests (complex, platform-specific)\n- ThriftClient unit tests (defer to Docker integration)\n- client.rs coverage (architectural decision to use mocks)\n\n### Open Questions\n- Exact coverage achievable without signals? (measure as we go)\n- Thread timeout values for tests? (use small values like 100ms)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-08T14:44:49.548124-05:00","updated_at":"2025-12-08T14:44:49.548124-05:00","source_repo":"."}
{"id":"osquery-rust-0r2","content_hash":"6b99bf63cf79222d880f8e034c62992b7a9c628e220b78817fd2eabae210f6dc","title":"Task 3: Add Docker integration tests for client.rs and server.rs","description":"","design":"## Goal\nCoordinate Docker-based integration tests to cover client.rs and server.rs paths requiring real osquery.\n\n## Context\n- Current coverage: 81.77% (need 95%)\n- client.rs: 14.29% (ThriftClient needs real osquery)\n- server.rs: 58.73% (start(), run() need real osquery)\n- This is a COORDINATOR task - broken into subtasks\n\n## Decisions Required (User Input Needed)\n\n**tests/ directory exception:**\nIntegration tests with testcontainers MUST be in tests/ directory per Rust convention.\nThe epic's 'no tests/ directory' anti-pattern was intended for unit tests, not integration tests.\n**DECISION:** Allow tests/integration_test.rs for Docker-based integration tests.\n\n**Docker image version:**\nUsing `osquery/osquery:5.12.1-ubuntu22.04` (latest stable as of Dec 2024).\nMust pin version to avoid CI flakiness from upstream changes.\n\n## Success Criteria\n- [ ] All 3 child subtasks closed\n- [ ] Integration tests pass: `cargo test --test integration_test`\n- [ ] Combined coverage \u003e= 95%: `cargo llvm-cov --ignore-filename-regex _osquery`\n- [ ] CI workflow includes Docker integration tests\n\n## Subtasks (see child issues)\n- osquery-rust-??? Task 3a: Set up testcontainers infrastructure\n- osquery-rust-??? Task 3b: Implement ThriftClient integration tests\n- osquery-rust-??? Task 3c: Add CI workflow for Docker tests","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-08T15:04:02.328186-05:00","updated_at":"2025-12-08T15:05:24.553061-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-0r2","depends_on_id":"osquery-rust-03d","type":"parent-child","created_at":"2025-12-08T15:04:08.16664-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-14q","content_hash":"fa08a8f4013f9eb0207103853dabd44bbb1417548f3ced4c942e45a8856ccd80","title":"Epic: Comprehensive Testing \u0026 Coverage Infrastructure","description":"","design":"## Requirements (IMMUTABLE)\n- All plugin traits (ReadOnlyTable, Table, LoggerPlugin, ConfigPlugin) have unit tests\n- Client communication is mockable via OsqueryClient trait abstraction\n- Server can be tested without real osquery sockets using mock client\n- TablePlugin enum dispatch is tested for all variants (Readonly, Writeable)\n- Code coverage is measured and reported in CI via cargo-llvm-cov\n- Coverage badge displays on main branch via dynamic-badges-action\n- All tests use mockall for auto-generated mocks where appropriate\n- Inline tests in modules using #[cfg(test)] (not separate tests/ directory)\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] ReadOnlyTable trait has generate() and columns() tests\n- [ ] Table trait has insert/update/delete tests\n- [ ] TablePlugin enum dispatches correctly to both variants\n- [ ] OsqueryClient trait extracted from Client struct\n- [ ] Server testable with MockOsqueryClient (no real sockets)\n- [ ] Handler::handle_call() routing tested\n- [ ] LoggerPluginWrapper all request types tested\n- [ ] ConfigPlugin gen_config/gen_pack tested\n- [ ] ExtensionResponseEnum conversion tested\n- [ ] QueryConstraints parsing tested\n- [ ] mockall added as dev-dependency\n- [ ] GitHub Actions coverage workflow added\n- [ ] Coverage badge integration configured\n- [ ] Line coverage \u003e= 60% (up from ~15%)\n- [ ] All tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO tests in separate tests/ directory (consistency: inline #[cfg(test)] modules per CLAUDE.md)\n- ❌ NO mocking Thrift layer directly (complexity: use trait abstractions instead)\n- ❌ NO unwrap/expect/panic in test code (clippy: project forbids these)\n- ❌ NO skipping Server mockability (testing: core requirement for comprehensive coverage)\n- ❌ NO breaking public API (backwards compat: Client type alias must remain)\n- ❌ NO coverage workflow without badge (visibility: must show progress)\n\n## Approach\n1. Add mockall as dev-dependency for auto-generated mocks\n2. Extract OsqueryClient trait from Client, keeping Client as type alias for backwards compat\n3. Make Server generic over client type with default ThriftClient\n4. Add comprehensive unit tests inline in each module\n5. Add shared test utilities in test_utils.rs (cfg(test) only)\n6. Add GitHub Actions coverage workflow with dynamic badge\n\n## Architecture\n- client.rs: OsqueryClient trait + ThriftClient impl + MockOsqueryClient (test)\n- server.rs: Server\u003cP, C: OsqueryClient = ThriftClient\u003e + Handler tests\n- plugin/table/mod.rs: TablePlugin tests, ReadOnlyTable/Table trait tests\n- plugin/logger/mod.rs: Complete LoggerPluginWrapper tests\n- plugin/config/mod.rs: ConfigPlugin tests\n- plugin/_enums/response.rs: ExtensionResponseEnum conversion tests\n- test_utils.rs: Shared TestTable, TestConfig, mock socket utilities\n\n## Design Rationale\n### Problem\nCurrent test coverage ~15-20% covers only server shutdown and logger features.\nCore functionality (table plugins, client communication, request routing) untested.\nNo coverage metrics to track progress or regressions.\n\n### Research Findings\n**Codebase:**\n- server_tests.rs:41-367 - Socket mocking pattern using tempfile + UnixListener\n- plugin/logger/mod.rs:463-494 - TestLogger pattern implementing trait directly\n- client.rs:7-87 - Client struct uses concrete UnixStream, not mockable\n- server.rs:67-81 - Server struct could be made generic over client\n\n**External:**\n- cargo-llvm-cov - 2025 standard for Rust coverage, LLVM source-based instrumentation\n- mockall 0.13 - Most popular Rust mocking library, generates mocks from traits\n- dynamic-badges-action - GitHub Action for coverage badges via gists\n\n### Approaches Considered\n1. **Trait abstraction + mockall + inline tests** ✓\n   - Pros: Mockable client, auto-generated mocks, follows existing patterns\n   - Cons: Adds dependency, requires refactoring Client\n   - **Chosen because:** Enables comprehensive testing without real sockets\n\n2. **Keep concrete types, test via real sockets only**\n   - Pros: No refactoring, simpler\n   - Cons: Cannot test Server without osquery, limited coverage possible\n   - **Rejected because:** Cannot achieve comprehensive coverage goal\n\n3. **Separate tests/ directory with integration tests**\n   - Pros: Standard Rust convention\n   - Cons: Breaks project pattern (CLAUDE.md specifies inline tests)\n   - **Rejected because:** Inconsistent with established codebase convention\n\n### Scope Boundaries\n**In scope:**\n- Unit tests for all plugin traits\n- Client trait abstraction for mockability\n- Handler/Server integration tests with mocks\n- Coverage infrastructure (cargo-llvm-cov, GitHub Actions, badge)\n- mockall dev-dependency\n\n**Out of scope (deferred/never):**\n- Property-based testing (proptest) - deferred to future epic\n- Fuzzing infrastructure - deferred to future epic\n- Mutation testing - deferred to future epic\n- End-to-end tests with real osquery binary - separate epic\n- Benchmark infrastructure - separate epic\n\n### Open Questions\n- Should MockOsqueryClient be generated by mockall or hand-rolled? (lean mockall)\n- Coverage threshold for CI failure? (suggest warning at 50%, fail at 40%)\n- Include doc tests in coverage? (default yes)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-08T12:25:11.446669-05:00","updated_at":"2025-12-08T14:46:58.229918-05:00","closed_at":"2025-12-08T14:46:58.229918-05:00","source_repo":"."}
{"id":"osquery-rust-1c2","content_hash":"40c19e3d85ffa474ac6df689b80e95d8eebc01afc475c1ded3a58c17810a2d8a","title":"Task 2: Add server.rs infrastructure tests","description":"","design":"## Goal\nAdd tests for server.rs infrastructure functions to increase coverage from 37.57% to ~80%.\n\n## Effort Estimate\n6-8 hours (9 tests across 4 function groups)\n\n## Context\nCompleted Task 1: util.rs (93.94%) and plugin.rs (90.56%)\nCoverage now at 79.49%, need 95% target\n\n## Implementation\n\n### Step 1: Add cleanup_socket() tests\nFile: osquery-rust/src/server_tests.rs (add to existing test module)\n\nFunctions involved:\n- cleanup_socket(\u0026self) at server.rs:400-414\n- Requires self.uuid = Some(uuid) and self.socket_path set\n- Constructs socket_path from format!(\"{}.{}\", self.socket_path, uuid)\n\nTests:\n1. test_cleanup_socket_removes_existing_socket\n   - Create tempdir + socket file\n   - Set server.uuid = Some(123), server.socket_path = tempdir path\n   - Call cleanup_socket()\n   - Verify socket file removed\n   \n2. test_cleanup_socket_handles_missing_socket  \n   - Set server.uuid = Some(123), server.socket_path = non-existent path\n   - Call cleanup_socket()\n   - Verify no panic, logs debug message\n   \n3. test_cleanup_socket_no_uuid_skips\n   - Set server.uuid = None\n   - Call cleanup_socket()\n   - Verify returns early, no file operations\n\n### Step 2: Add notify_plugins_shutdown() tests\nFile: osquery-rust/src/server_tests.rs\n\nFunction: notify_plugins_shutdown(\u0026self) at server.rs:386-396\n- Iterates self.plugins calling shutdown() with catch_unwind\n- Logs error if plugin panics but continues to other plugins\n\nTests:\n1. test_notify_plugins_shutdown_single_plugin\n   - Create Server with one mock plugin (Arc\u003cAtomicBool\u003e shutdown flag)\n   - Call notify_plugins_shutdown()\n   - Verify shutdown flag set to true\n   \n2. test_notify_plugins_shutdown_multiple_plugins\n   - Create Server with 3 mock plugins\n   - Call notify_plugins_shutdown()\n   - Verify ALL shutdown flags set (all plugins notified)\n   \n3. test_notify_plugins_shutdown_empty_plugins\n   - Create Server with empty plugins vec\n   - Call notify_plugins_shutdown()\n   - Verify no panic (handles empty list)\n\n### Step 3: Add join_listener_thread() tests\nFile: osquery-rust/src/server_tests.rs\n\nFunction: join_listener_thread(\u0026mut self) at server.rs:241-268\n- Takes self.listener_thread, waits for it with timeout\n- Calls wake_listener() to unblock accept()\n- Handles thread panic case\n\nTests:\n1. test_join_listener_thread_no_thread\n   - Server with listener_thread = None\n   - Call join_listener_thread()\n   - Verify returns immediately without panic\n   \n2. test_join_listener_thread_finished_thread\n   - Create JoinHandle for already-finished thread\n   - Set as listener_thread\n   - Call join_listener_thread()\n   - Verify joins successfully\n\nNOTE: Full timeout test is hard without real blocking - coverage goal is partial.\n\n### Step 4: Add wake_listener() tests\nFile: osquery-rust/src/server_tests.rs\n\nFunction: wake_listener(\u0026self) at server.rs:378-382\n- Connects to self.listen_path to wake blocking accept()\n- Uses let _ = to ignore connection errors\n\nTests:\n1. test_wake_listener_with_path\n   - Set server.listen_path = Some(temp socket path)\n   - Create Unix listener on that path\n   - Call wake_listener()\n   - Verify connection received on listener\n   \n2. test_wake_listener_no_path\n   - Set server.listen_path = None\n   - Call wake_listener()\n   - Verify no panic (early return)\n\n### Step 5: Verify\n- Run cargo test --all-features\n- Run cargo llvm-cov --ignore-filename-regex _osquery\n- Run .git/hooks/pre-commit\n\n## Success Criteria\n- [ ] test_cleanup_socket_removes_existing_socket passes\n- [ ] test_cleanup_socket_handles_missing_socket passes\n- [ ] test_cleanup_socket_no_uuid_skips passes\n- [ ] test_notify_plugins_shutdown_single_plugin passes\n- [ ] test_notify_plugins_shutdown_multiple_plugins passes\n- [ ] test_notify_plugins_shutdown_empty_plugins passes\n- [ ] test_join_listener_thread_no_thread passes\n- [ ] test_join_listener_thread_finished_thread passes\n- [ ] test_wake_listener_with_path passes\n- [ ] test_wake_listener_no_path passes\n- [ ] server.rs coverage \u003e= 60% (from 37.57%)\n- [ ] All tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE Review)\n\n**Accessing Private Methods**:\n- All target functions are private (fn not pub fn)\n- Tests must be in server_tests.rs module to access via Server struct\n- May need to expose some internals for testability\n\n**Thread Testing Complexity**:\n- join_listener_thread() full coverage requires real blocking threads\n- Focus on boundary cases (no thread, finished thread)\n- Full timeout path may need integration tests later\n\n**Mock Plugin Pattern**:\n- Use same Arc\u003cAtomicBool\u003e pattern from Task 1 for shutdown verification\n- Create simple TestPlugin struct implementing OsqueryPlugin\n\n**Tempfile Usage**:\n- Use tempfile crate for socket paths (already in dev-dependencies)\n- Ensures cleanup after tests\n\n**Coverage Target Realistic**:\n- 60% target vs 80% due to thread/signal paths being hard to unit test\n- Full server.rs coverage needs integration tests with osquery\n\n## Anti-Patterns\n- ❌ NO unwrap/expect in test code (use safe patterns)\n- ❌ NO hardcoded paths (use tempfile)\n- ❌ NO sleep-based synchronization (use proper sync primitives)\n- ❌ NO ignoring cleanup (use RAII/Drop patterns)\n- ❌ NO testing mock behavior instead of real behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T14:51:55.112505-05:00","updated_at":"2025-12-08T14:58:49.187896-05:00","closed_at":"2025-12-08T14:58:49.187896-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-1c2","depends_on_id":"osquery-rust-03d","type":"parent-child","created_at":"2025-12-08T14:52:00.610427-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-1c2","depends_on_id":"osquery-rust-8en","type":"blocks","created_at":"2025-12-08T14:52:01.145249-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-2ia","content_hash":"6cb04c36b5738e412a5287be85e18f0b47f60db5bd00fc3319a27c8ba0a7b12e","title":"Task 4: Add GitHub Actions coverage workflow and badge","description":"","design":"## Goal\nAdd coverage measurement infrastructure with GitHub Actions workflow and dynamic badge.\n\n## Context\n- Epic osquery-rust-14q requires coverage \u003e= 60% and badge visibility\n- User provided gist ID: 36626ec8e61a6ccda380befc41f2cae1\n- All unit tests complete (67 tests passing)\n\n## Implementation\n\n### Step 1: Create .github/workflows/coverage.yml\n```yaml\nname: Coverage\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          components: llvm-tools-preview\n      - uses: taiki-e/install-action@cargo-llvm-cov\n      - name: Generate coverage\n        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info\n      - name: Generate coverage summary\n        id: coverage\n        run: |\n          COVERAGE=$(cargo llvm-cov --all-features --workspace --json | jq '.data[0].totals.lines.percent')\n          echo \"coverage=$COVERAGE\" \u003e\u003e $GITHUB_OUTPUT\n      - name: Update coverage badge\n        if: github.ref == 'refs/heads/main'\n        uses: schneegans/dynamic-badges-action@v1.7.0\n        with:\n          auth: ${{ secrets.GIST_TOKEN }}\n          gistID: 36626ec8e61a6ccda380befc41f2cae1\n          filename: coverage.json\n          label: coverage\n          message: ${{ steps.coverage.outputs.coverage }}%\n          valColorRange: ${{ steps.coverage.outputs.coverage }}\n          maxColorRange: 100\n          minColorRange: 0\n```\n\n### Step 2: Update README.md with badge\nAdd badge to README showing coverage from gist.\n\n### Step 3: Run local coverage check\nRun cargo-llvm-cov locally to verify \u003e= 60% coverage.\n\n## Success Criteria\n- [ ] .github/workflows/coverage.yml created\n- [ ] Workflow uses cargo-llvm-cov\n- [ ] Badge updates on main branch push\n- [ ] Gist ID 36626ec8e61a6ccda380befc41f2cae1 used\n- [ ] Local coverage measured \u003e= 60%","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T14:20:25.620702-05:00","updated_at":"2025-12-08T14:22:48.036302-05:00","closed_at":"2025-12-08T14:22:48.036302-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-2ia","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T14:20:34.041915-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-40t","content_hash":"1a628397bdf7a621be986d6294fe9740bd42b88d39f3988116974e1ff90da0b6","title":"Task 3b: Implement ThriftClient integration tests","description":"","design":"## Goal\nImplement integration tests for ThriftClient that exercise real osquery socket communication.\n\n## Effort Estimate\n4-6 hours\n\n## Implementation Checklist\n\n### Step 1: Create osquery container helper\nFile: osquery-rust/tests/integration_test.rs (add to existing)\n\n```rust\nuse std::path::PathBuf;\nuse testcontainers::{core::WaitFor, runners::SyncRunner, GenericImage, ImageExt};\n\n/// Create osquery container with extensions socket mounted\nfn start_osquery_with_socket() -\u003e (testcontainers::Container\u003cGenericImage\u003e, PathBuf) {\n    let temp_dir = tempfile::tempdir().expect(\"Failed to create temp dir\");\n    let socket_dir = temp_dir.path().to_path_buf();\n    \n    let container = GenericImage::new(OSQUERY_IMAGE, OSQUERY_TAG)\n        .with_volume(socket_dir.to_str().unwrap(), \"/var/osquery\")\n        .with_cmd(vec![\n            \"osqueryd\",\n            \"--ephemeral\",\n            \"--disable_extensions=false\",\n            \"--extensions_socket=/var/osquery/osquery.em\",\n            \"--logger_plugin=filesystem\",\n            \"--logger_path=/tmp\",\n        ])\n        .with_wait_for(WaitFor::message_on_stderr(\"Listening on\"))\n        .start()\n        .expect(\"Failed to start osquery\");\n    \n    let socket_path = socket_dir.join(\"osquery.em\");\n    (container, socket_path)\n}\n```\n\n### Step 2: Add ThriftClient connection test\n```rust\nuse osquery_rust_ng::client::ThriftClient;\n\n#[test]\nfn test_thrift_client_connects_to_osquery() {\n    let (_container, socket_path) = start_osquery_with_socket();\n    \n    // Wait for socket to appear\n    let start = std::time::Instant::now();\n    while !socket_path.exists() \u0026\u0026 start.elapsed() \u003c STARTUP_TIMEOUT {\n        std::thread::sleep(Duration::from_millis(100));\n    }\n    assert!(socket_path.exists(), \"Socket not created within timeout\");\n    \n    // Connect ThriftClient\n    let client = ThriftClient::new(\n        socket_path.to_str().unwrap(),\n        Default::default()\n    );\n    \n    assert!(client.is_ok(), \"ThriftClient::new failed: {:?}\", client.err());\n}\n```\n\n### Step 3: Add ping test\n```rust\n#[test]\nfn test_thrift_client_ping() {\n    let (_container, socket_path) = start_osquery_with_socket();\n    wait_for_socket(\u0026socket_path);\n    \n    let mut client = ThriftClient::new(\n        socket_path.to_str().unwrap(),\n        Default::default()\n    ).expect(\"Failed to create client\");\n    \n    let result = client.ping();\n    assert!(result.is_ok(), \"Ping failed: {:?}\", result.err());\n}\n```\n\n### Step 4: Add extension registration test\n```rust\nuse osquery_rust_ng::_osquery::InternalExtensionInfo;\n\n#[test]\nfn test_extension_registration() {\n    let (_container, socket_path) = start_osquery_with_socket();\n    wait_for_socket(\u0026socket_path);\n    \n    let mut client = ThriftClient::new(\n        socket_path.to_str().unwrap(),\n        Default::default()\n    ).expect(\"Failed to create client\");\n    \n    let info = InternalExtensionInfo {\n        name: Some(\"test_extension\".to_string()),\n        version: Some(\"1.0\".to_string()),\n        sdk_version: Some(\"1.0\".to_string()),\n        min_sdk_version: Some(\"1.0\".to_string()),\n    };\n    \n    let result = client.register_extension(info, Default::default());\n    assert!(result.is_ok(), \"Registration failed: {:?}\", result.err());\n    \n    let status = result.unwrap();\n    assert_eq!(status.code, Some(0), \"Registration returned error: {:?}\", status.message);\n    assert!(status.uuid.is_some(), \"No UUID returned\");\n}\n```\n\n### Step 5: Run and verify coverage\n```bash\ncargo test --test integration_test\ncargo llvm-cov --ignore-filename-regex _osquery\n```\n\n## Success Criteria\n- [ ] test_thrift_client_connects_to_osquery passes\n- [ ] test_thrift_client_ping passes  \n- [ ] test_extension_registration passes\n- [ ] client.rs coverage \u003e= 50% (up from 14.29%)\n- [ ] `cargo clippy --all-features --tests` passes\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE Review)\n\n**Socket Mount Complexity:**\n- osquery in Docker needs volume mount for socket\n- Socket appears asynchronously after osqueryd starts\n- MUST wait for socket file, not just container start\n- tempfile ensures cleanup on test completion\n\n**osqueryd Command Flags:**\n- `--ephemeral`: Don't persist database, cleaner tests\n- `--disable_extensions=false`: Required for extension socket\n- `--extensions_socket`: Must match mounted path\n- `--logger_plugin=filesystem`: Avoid syslog issues in container\n\n**Socket Wait Pattern:**\n- Container 'ready' != socket exists\n- Poll for socket file with timeout\n- 30 second timeout catches stuck osquery\n\n**Registration Requirements:**\n- InternalExtensionInfo requires all 4 fields (name, version, sdk_version, min_sdk_version)\n- Empty registry is valid for ping-only test\n- UUID in response indicates successful registration\n\n**Parallel Test Isolation:**\n- Each test creates own temp directory\n- Each test starts own container\n- No shared state between tests\n\n## Anti-Patterns\n- ❌ NO socket path assumptions (use tempfile)\n- ❌ NO sleep without timeout (always poll with deadline)\n- ❌ NO container reuse across tests (isolation)\n- ❌ NO ignoring test failures with `#[ignore]`","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T15:06:23.085605-05:00","updated_at":"2025-12-08T15:26:57.932219-05:00","closed_at":"2025-12-08T15:26:57.932219-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-40t","depends_on_id":"osquery-rust-0r2","type":"parent-child","created_at":"2025-12-08T15:06:28.627522-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-40t","depends_on_id":"osquery-rust-x7l","type":"blocks","created_at":"2025-12-08T15:06:29.172315-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-5k9","content_hash":"30768e102b7bb8416468b7c394b638267290f77e7530808d1c354ee0ba912791","title":"Task 3c: Add CI workflow for Docker integration tests","description":"","design":"## Goal\nAdd GitHub Actions workflow to run Docker integration tests in CI.\n\n## Effort Estimate\n2-3 hours\n\n## Implementation Checklist\n\n### Step 1: Create integration test workflow\nFile: .github/workflows/integration-tests.yml\n\n```yaml\nname: Integration Tests\n\non:\n  push:\n    branches: [main, testing-refactor]\n  pull_request:\n    branches: [main]\n\nenv:\n  CARGO_TERM_COLOR: always\n  # Pre-pull osquery image to avoid test timeouts\n  OSQUERY_IMAGE: osquery/osquery:5.12.1-ubuntu22.04\n\njobs:\n  integration:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Install Rust toolchain\n      uses: dtolnay/rust-action@stable\n    \n    - name: Cache cargo\n      uses: actions/cache@v4\n      with:\n        path: |\n          ~/.cargo/registry\n          ~/.cargo/git\n          target\n        key: ${{ runner.os }}-cargo-integration-${{ hashFiles('**/Cargo.lock') }}\n    \n    - name: Pre-pull osquery image\n      run: docker pull $OSQUERY_IMAGE\n    \n    - name: Run integration tests\n      run: cargo test --test integration_test --verbose\n      timeout-minutes: 10\n```\n\n### Step 2: Add coverage workflow with integration tests\nFile: .github/workflows/coverage.yml (update existing or create)\n\n```yaml\nname: Coverage\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Install Rust toolchain\n      uses: dtolnay/rust-action@nightly\n      with:\n        components: llvm-tools-preview\n    \n    - name: Install cargo-llvm-cov\n      uses: taiki-e/install-action@cargo-llvm-cov\n    \n    - name: Pre-pull osquery image\n      run: docker pull osquery/osquery:5.12.1-ubuntu22.04\n    \n    - name: Generate coverage (unit + integration)\n      run: |\n        cargo llvm-cov clean --workspace\n        cargo llvm-cov --no-report --all-features\n        cargo llvm-cov --no-report --test integration_test\n        cargo llvm-cov report --lcov --output-path lcov.info --ignore-filename-regex _osquery\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v4\n      with:\n        files: lcov.info\n        fail_ci_if_error: false\n```\n\n### Step 3: Add badge to README\n```markdown\n[\\![Integration Tests](https://github.com/OWNER/REPO/actions/workflows/integration-tests.yml/badge.svg)](https://github.com/OWNER/REPO/actions/workflows/integration-tests.yml)\n```\n\n### Step 4: Verify workflow syntax\n```bash\n# Validate YAML syntax locally\npython3 -c \"import yaml; yaml.safe_load(open('.github/workflows/integration-tests.yml'))\"\n```\n\n## Success Criteria\n- [ ] .github/workflows/integration-tests.yml exists and is valid YAML\n- [ ] Workflow runs on push to main and testing-refactor branches\n- [ ] Pre-pulls osquery image before tests (avoids timeout)\n- [ ] Has 10-minute timeout (catches stuck containers)\n- [ ] `cargo test --test integration_test` runs in workflow\n- [ ] Coverage workflow includes integration tests\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE Review)\n\n**GitHub Actions Docker Support:**\n- ubuntu-latest includes Docker pre-installed\n- No need for docker-compose (testcontainers handles lifecycle)\n- Docker layer caching via actions/cache helps subsequent runs\n\n**Image Pre-Pull:**\n- osquery image is ~500MB\n- testcontainers timeout may be too short for first pull\n- Pre-pull in separate step with no timeout\n\n**Timeout Settings:**\n- 10-minute job timeout catches hung tests\n- Individual test timeout in testcontainers (30s)\n- If tests consistently timeout, increase STARTUP_TIMEOUT constant\n\n**Coverage Merging:**\n- cargo-llvm-cov automatically merges multiple --no-report runs\n- Final report command generates combined coverage\n- Must use same toolchain (nightly) for all coverage runs\n\n**Branch Triggers:**\n- Include testing-refactor branch during development\n- Remove after merge to main\n\n## Anti-Patterns\n- ❌ NO workflow without timeout-minutes (can hang forever)\n- ❌ NO hard-coded secrets in workflow (use GitHub secrets)\n- ❌ NO continue-on-error: true for test steps (hides failures)\n- ❌ NO skip of coverage upload on PR (need feedback)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T15:06:53.081548-05:00","updated_at":"2025-12-08T15:06:53.081548-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-5k9","depends_on_id":"osquery-rust-0r2","type":"parent-child","created_at":"2025-12-08T15:07:00.692054-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-5k9","depends_on_id":"osquery-rust-40t","type":"blocks","created_at":"2025-12-08T15:07:01.22702-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-7bs","content_hash":"f6eb1a585ff838ace71c108700d111c450778dc01e04e4d9fef02f9b0e8eb382","title":"Task 1: Add mockall dependency and TablePlugin unit tests","description":"","design":"## Goal\nAdd mockall as dev-dependency and create comprehensive unit tests for TablePlugin enum dispatch and ReadOnlyTable/Table trait implementations. Tests must cover happy paths, error paths, and edge cases.\n\n## Effort Estimate\n6-8 hours\n\n## Study Existing Patterns\n- plugin/logger/mod.rs:463-494 - TestLogger pattern (struct with configurable state)\n- server_tests.rs - tempfile and assertion patterns\n- plugin/table/mod.rs:20-291 - TablePlugin enum, traits, result enums\n\n## Implementation\n\n### Step 1: Add mockall dependency\nFile: osquery-rust/Cargo.toml\n```toml\n[dev-dependencies]\ntempfile = \"^3.14\"\nmockall = \"0.13\"\n```\n\n### Step 2: Create TestReadOnlyTable mock\nFile: osquery-rust/src/plugin/table/mod.rs (at bottom, inside #[cfg(test)])\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::_osquery::osquery;\n\n    struct TestReadOnlyTable {\n        test_name: String,\n        test_columns: Vec\u003cColumnDef\u003e,\n        test_rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e,\n    }\n\n    impl TestReadOnlyTable {\n        fn new(name: \u0026str) -\u003e Self {\n            Self {\n                test_name: name.to_string(),\n                test_columns: vec![\n                    ColumnDef::new(\"id\", ColumnType::Integer),\n                    ColumnDef::new(\"value\", ColumnType::Text),\n                ],\n                test_rows: vec![],\n            }\n        }\n\n        fn with_rows(mut self, rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e) -\u003e Self {\n            self.test_rows = rows;\n            self\n        }\n    }\n\n    impl ReadOnlyTable for TestReadOnlyTable {\n        fn name(\u0026self) -\u003e String { self.test_name.clone() }\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { self.test_columns.clone() }\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            ExtensionResponse::new(\n                osquery::ExtensionStatus {\n                    code: Some(0),\n                    message: Some(\"OK\".to_string()),\n                    uuid: None,\n                },\n                self.test_rows.clone(),\n            )\n        }\n        fn shutdown(\u0026self) {}\n    }\n}\n```\n\n### Step 3: Create TestWriteableTable mock\n```rust\n    struct TestWriteableTable {\n        test_name: String,\n        test_columns: Vec\u003cColumnDef\u003e,\n        data: BTreeMap\u003cu64, BTreeMap\u003cString, String\u003e\u003e,\n        next_id: u64,\n    }\n\n    impl TestWriteableTable {\n        fn new(name: \u0026str) -\u003e Self {\n            Self {\n                test_name: name.to_string(),\n                test_columns: vec![\n                    ColumnDef::new(\"id\", ColumnType::Integer),\n                    ColumnDef::new(\"value\", ColumnType::Text),\n                ],\n                data: BTreeMap::new(),\n                next_id: 1,\n            }\n        }\n    }\n\n    impl Table for TestWriteableTable {\n        fn name(\u0026self) -\u003e String { self.test_name.clone() }\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { self.test_columns.clone() }\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            let rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e = self.data.values().cloned().collect();\n            ExtensionResponse::new(\n                osquery::ExtensionStatus { code: Some(0), message: Some(\"OK\".to_string()), uuid: None },\n                rows,\n            )\n        }\n        fn update(\u0026mut self, rowid: u64, row: \u0026serde_json::Value) -\u003e UpdateResult {\n            if self.data.contains_key(\u0026rowid) {\n                let mut r = BTreeMap::new();\n                if let Some(val) = row.get(1).and_then(|v| v.as_str()) {\n                    r.insert(\"value\".to_string(), val.to_string());\n                }\n                self.data.insert(rowid, r);\n                UpdateResult::Success\n            } else {\n                UpdateResult::Err(\"Row not found\".to_string())\n            }\n        }\n        fn delete(\u0026mut self, rowid: u64) -\u003e DeleteResult {\n            if self.data.remove(\u0026rowid).is_some() {\n                DeleteResult::Success\n            } else {\n                DeleteResult::Err(\"Row not found\".to_string())\n            }\n        }\n        fn insert(\u0026mut self, auto_rowid: bool, row: \u0026serde_json::Value) -\u003e InsertResult {\n            let id = if auto_rowid { self.next_id } else {\n                row.get(0).and_then(|v| v.as_u64()).unwrap_or(self.next_id)\n            };\n            let mut r = BTreeMap::new();\n            r.insert(\"id\".to_string(), id.to_string());\n            if let Some(val) = row.get(1).and_then(|v| v.as_str()) {\n                r.insert(\"value\".to_string(), val.to_string());\n            }\n            self.data.insert(id, r);\n            self.next_id = id + 1;\n            InsertResult::Success(id)\n        }\n        fn shutdown(\u0026self) {}\n    }\n```\n\n### Step 4: Implement tests\n\n```rust\n    // --- ReadOnlyTable tests ---\n\n    #[test]\n    fn test_readonly_table_plugin_name() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        assert_eq!(plugin.name(), \"test_table\");\n    }\n\n    #[test]\n    fn test_readonly_table_plugin_columns() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        let routes = plugin.routes();\n        assert_eq!(routes.len(), 2); // id and value columns\n        assert_eq!(routes[0].get(\"name\"), Some(\u0026\"id\".to_string()));\n        assert_eq!(routes[1].get(\"name\"), Some(\u0026\"value\".to_string()));\n    }\n\n    #[test]\n    fn test_readonly_table_plugin_generate() {\n        let mut row = BTreeMap::new();\n        row.insert(\"id\".to_string(), \"1\".to_string());\n        row.insert(\"value\".to_string(), \"test\".to_string());\n        let table = TestReadOnlyTable::new(\"test_table\").with_rows(vec![row]);\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"generate\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0));\n        assert_eq!(response.response.len(), 1);\n    }\n\n    #[test]\n    fn test_readonly_table_routes_via_handle_call() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"columns\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0));\n        assert_eq!(response.response.len(), 2); // 2 columns\n    }\n\n    // --- Writeable table tests ---\n\n    #[test]\n    fn test_writeable_table_insert() {\n        let table = TestWriteableTable::new(\"test_table\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        req.insert(\"auto_rowid\".to_string(), \"true\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[null, \\\"test_value\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    #[test]\n    fn test_writeable_table_update() {\n        let mut table = TestWriteableTable::new(\"test_table\");\n        // Pre-insert a row\n        table.insert(true, \u0026serde_json::json!([null, \"initial\"]));\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"updated\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    #[test]\n    fn test_writeable_table_delete() {\n        let mut table = TestWriteableTable::new(\"test_table\");\n        table.insert(true, \u0026serde_json::json!([null, \"to_delete\"]));\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    // --- Dispatch tests ---\n\n    #[test]\n    fn test_table_plugin_dispatch_readonly() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        assert!(matches!(plugin, TablePlugin::Readonly(_)));\n        assert_eq!(plugin.registry(), Registry::Table);\n    }\n\n    #[test]\n    fn test_table_plugin_dispatch_writeable() {\n        let table = TestWriteableTable::new(\"writeable\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        assert!(matches!(plugin, TablePlugin::Writeable(_)));\n        assert_eq!(plugin.registry(), Registry::Table);\n    }\n\n    // --- Error path tests ---\n\n    #[test]\n    fn test_readonly_table_insert_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        // Readonly error returns code 2 (see ExtensionResponseEnum::Readonly)\n        assert_eq!(response.status.code, Some(2));\n    }\n\n    #[test]\n    fn test_readonly_table_update_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(2)); // Readonly error\n    }\n\n    #[test]\n    fn test_readonly_table_delete_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(2)); // Readonly error\n    }\n\n    #[test]\n    fn test_invalid_action_returns_error() {\n        let table = TestReadOnlyTable::new(\"test\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"invalid_action\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n\n    #[test]\n    fn test_update_with_invalid_id_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"not_a_number\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure - cannot parse id\n    }\n\n    #[test]\n    fn test_update_with_invalid_json_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"not valid json\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure - invalid JSON\n    }\n\n    #[test]\n    fn test_insert_with_missing_json_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        // Missing json_value_array\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n\n    #[test]\n    fn test_delete_with_missing_id_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        // Missing id\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n```\n\n## Implementation Checklist\n- [ ] osquery-rust/Cargo.toml:47-48 - add mockall = \"0.13\" to [dev-dependencies]\n- [ ] osquery-rust/src/plugin/table/mod.rs:292+ - add #[cfg(test)] mod tests\n- [ ] mod tests - TestReadOnlyTable struct with new(), with_rows() builder\n- [ ] mod tests - TestWriteableTable struct with CRUD state\n- [ ] mod tests - test_readonly_table_plugin_name() verifies name()\n- [ ] mod tests - test_readonly_table_plugin_columns() verifies routes() returns 2 columns\n- [ ] mod tests - test_readonly_table_plugin_generate() verifies generate returns rows\n- [ ] mod tests - test_readonly_table_routes_via_handle_call() verifies columns action\n- [ ] mod tests - test_writeable_table_insert() verifies insert returns success\n- [ ] mod tests - test_writeable_table_update() verifies update returns success\n- [ ] mod tests - test_writeable_table_delete() verifies delete returns success\n- [ ] mod tests - test_table_plugin_dispatch_readonly() verifies enum variant\n- [ ] mod tests - test_table_plugin_dispatch_writeable() verifies enum variant\n- [ ] mod tests - test_readonly_table_insert_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_readonly_table_update_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_readonly_table_delete_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_invalid_action_returns_error() verifies code 1\n- [ ] mod tests - test_update_with_invalid_id_returns_error() verifies code 1\n- [ ] mod tests - test_update_with_invalid_json_returns_error() verifies code 1\n- [ ] mod tests - test_insert_with_missing_json_returns_error() verifies code 1\n- [ ] mod tests - test_delete_with_missing_id_returns_error() verifies code 1\n\n## Success Criteria\n- [ ] mockall = \"0.13\" added to [dev-dependencies] in Cargo.toml\n- [ ] 20 table plugin tests implemented and passing\n- [ ] Tests cover: name(), columns(), generate(), insert(), update(), delete()\n- [ ] Tests cover: TablePlugin::Readonly and TablePlugin::Writeable dispatch\n- [ ] Tests cover: readonly error (code 2) for write ops on ReadOnlyTable\n- [ ] Tests cover: failure (code 1) for invalid action, bad id, bad JSON, missing params\n- [ ] cargo test --all-features passes with 0 failures\n- [ ] cargo clippy --all-features passes with 0 warnings\n- [ ] .git/hooks/pre-commit passes\n\n## Key Considerations (SRE REVIEW)\n\n**Edge Case: Empty columns/rows**\n- TestReadOnlyTable with empty columns should return empty routes\n- generate() with no rows should return success with empty response array\n- Both are valid states, not errors\n\n**Edge Case: Mutex poisoning**\n- If panic occurs while holding Mutex lock, subsequent lock() calls return Err\n- Code handles this gracefully (returns \"unable-to-get-table-name\" or Failure response)\n- Tests do NOT need to verify mutex poisoning (requires unsafe code to trigger)\n- Document that mutex poisoning is handled but not directly tested\n\n**Edge Case: Invalid JSON parsing**\n- json_value_array with malformed JSON must return Failure (code 1)\n- Empty string \"\" is invalid JSON, should return error\n- Tests verify: \"not valid json\" returns error\n\n**Edge Case: Non-numeric id**\n- update/delete with id=\"not_a_number\" must return Failure (code 1)\n- Tests verify this path explicitly\n\n**Reference Implementation**\n- plugin/logger/mod.rs:463-494 shows TestLogger pattern\n- server_tests.rs shows assertion patterns without unwrap\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO unwrap() or expect() in test code (use assert_eq! or pattern matching)\n- ❌ NO panic!() or todo!() stubs\n- ❌ NO placeholder comments like \"// TODO\"\n- ❌ NO testing Mutex poisoning (requires unsafe, out of scope)\n- ❌ NO using mockall for these tests (hand-rolled mocks are clearer here)","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T12:25:29.599561-05:00","updated_at":"2025-12-08T12:33:34.953114-05:00","closed_at":"2025-12-08T12:33:34.953114-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-7bs","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T12:25:34.786923-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-81n","content_hash":"d0862f43d7f6ece74e668b81da615d868bd21a60ce4922b0dc57b61807f03e07","title":"Task 2: Add test_query_osquery_info integration test","description":"","design":"## Goal\nAdd integration test that queries osquery's built-in osquery_info table using the new OsqueryClient::query() method.\n\n## Context\nCompleted bd-p6i: Added query() and get_query_columns() to OsqueryClient trait. Now we can use these methods in integration tests.\n\n## Implementation\n\n### 1. Study existing integration tests\n- tests/integration_test.rs - existing test_thrift_client_connects_to_osquery and test_thrift_client_ping\n\n### 2. Write test (following existing pattern)\nAdd to tests/integration_test.rs:\n\n```rust\n#[test]\nfn test_query_osquery_info() {\n    let socket_path = get_osquery_socket();\n    println!(\"Using osquery socket: {}\", socket_path);\n    \n    let mut client = ThriftClient::new(\u0026socket_path, Duration::from_secs(30))\n        .expect(\"Failed to connect to osquery\");\n    \n    // Query osquery_info table - built-in table that always exists\n    let result = client.query(\"SELECT * FROM osquery_info\".to_string());\n    assert!(result.is_ok(), \"Query should succeed\");\n    \n    let response = result.expect(\"Should have response\");\n    \n    // Verify status\n    let status = response.status.expect(\"Should have status\");\n    assert_eq!(status.code, Some(0), \"Query should return success status\");\n    \n    // Verify we got rows back\n    let rows = response.response.expect(\"Should have response rows\");\n    assert!(!rows.is_empty(), \"osquery_info should return at least one row\");\n    \n    println!(\"SUCCESS: Query returned {} rows\", rows.len());\n}\n```\n\n### 3. Run test locally\n```bash\n# First start osqueryi for testing\nosqueryi --nodisable_extensions --extensions_socket=/tmp/test.sock\n\n# Run integration tests\ncargo test --test integration_test test_query_osquery_info\n```\n\n## Success Criteria\n- [ ] test_query_osquery_info exists in tests/integration_test.rs\n- [ ] Test queries SELECT * FROM osquery_info\n- [ ] Test verifies status code is 0 (success)\n- [ ] Test verifies at least one row is returned\n- [ ] Test passes when osquery socket available\n- [ ] Test FAILS (not skips) when osquery unavailable\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO mocking osquery - this is integration test\n- ❌ NO skipping when osquery unavailable - must fail to surface infra issues\n- ❌ NO using Docker in test code - native osquery only","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T16:45:16.680297-05:00","updated_at":"2025-12-08T16:53:51.581231-05:00","closed_at":"2025-12-08T16:53:51.581231-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-81n","depends_on_id":"osquery-rust-86j","type":"parent-child","created_at":"2025-12-08T16:45:22.695689-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-81n","depends_on_id":"osquery-rust-p6i","type":"blocks","created_at":"2025-12-08T16:45:23.267804-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-86j","content_hash":"24d0e421f8287dcf6eb57f6a4600d8c8a6e2efb299ba87a3f9176c74c75dda9e","title":"Epic: Integration Tests for Full Thrift Coverage","description":"","design":"## Requirements (IMMUTABLE)\n- Expand OsqueryClient trait with query() and get_query_columns() methods\n- Add integration test for querying osquery built-in tables (osquery_info)\n- Add integration test for full Server lifecycle (register → run → stop → deregister)\n- Add integration test for table plugin end-to-end (register table, query via osquery, verify response)\n- All tests FAIL (not skip) when osquery unavailable\n- Tests use native osquery (no Docker/QEMU in tests themselves)\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] OsqueryClient trait includes query() and get_query_columns()\n- [ ] test_query_osquery_info() passes - queries SELECT * FROM osquery_info\n- [ ] test_server_lifecycle() passes - full register/deregister cycle\n- [ ] test_table_plugin_end_to_end() passes - osquery queries our test table\n- [ ] Thrift code coverage (osquery.rs) increases from 5.4% to \u003e15%\n- [ ] All existing tests still pass\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO mocking osquery in integration tests (validation: defeats purpose of testing real integration)\n- ❌ NO skipping tests when osquery unavailable (reliability: tests must fail to surface infra issues)\n- ❌ NO adding query() as standalone method (consistency: must be part of OsqueryClient trait)\n- ❌ NO re-exporting internal Thrift traits (encapsulation: _osquery must stay pub(crate))\n- ❌ NO Docker in test code (performance: use native osquery, Docker only in pre-commit hook)\n\n## Approach\nExtend the OsqueryClient trait to expose query() and get_query_columns() methods, enabling integration tests to execute SQL against osquery. Then add three new integration tests:\n1. Query osquery's built-in tables to test the query RPC\n2. Test Server lifecycle to verify register/deregister flows\n3. End-to-end table plugin test where osquery queries our registered extension table\n\n## Architecture\n- client.rs: Expand OsqueryClient trait with query methods\n- tests/integration_test.rs: Add 3 new test functions\n- Test table: Simple ReadOnlyTable returning static rows for verification\n- All tests share get_osquery_socket() helper for socket discovery\n\n## Design Rationale\n### Problem\nCurrent integration tests only cover ping() RPC (5.4% Thrift coverage). The query(), register_extension(), and table plugin call flows are untested against real osquery, leaving significant code paths unvalidated.\n\n### Research Findings\n**Codebase:**\n- client.rs:82 - query() exists but only via TExtensionManagerSyncClient trait (not exported)\n- client.rs:13-29 - OsqueryClient trait is the public interface for osquery communication\n- server.rs:270-327 - Server.start() handles registration and returns UUID\n- plugin/table/mod.rs:88-114 - TablePlugin.handle_call() dispatches generate/update/delete/insert\n\n**External:**\n- osquery extensions protocol requires register_extension before table queries work\n- Query RPC returns ExtensionResponse with status and rows\n\n### Approaches Considered\n1. **Extend OsqueryClient trait** ✓\n   - Pros: Clean public API, mockable, consistent with existing pattern\n   - Cons: Slightly larger trait surface\n   - **Chosen because:** Matches existing codebase pattern, enables mocking in unit tests\n\n2. **Re-export TExtensionManagerSyncClient**\n   - Pros: No code changes to client.rs\n   - Cons: Exposes internal Thrift details, breaks encapsulation\n   - **Rejected because:** Violates pub(crate) design intent\n\n3. **Standalone methods on ThriftClient**\n   - Pros: Simple addition\n   - Cons: Inconsistent with trait-based design, not mockable\n   - **Rejected because:** Doesn't work with MockOsqueryClient for unit tests\n\n### Scope Boundaries\n**In scope:**\n- Expand OsqueryClient trait with query methods\n- 3 new integration tests\n- Test table implementation in integration_test.rs\n\n**Out of scope (deferred/never):**\n- Testing writeable table operations (insert/update/delete) - defer to future epic\n- Testing config/logger plugins - defer to future epic\n- Coverage for all Thrift error paths - not practical\n\n### Open Questions\n- Should test_server_lifecycle() verify the extension appears in osquery's extension list? (decide during implementation)\n- Timeout values for server startup in tests? (use existing 30s pattern)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-08T16:39:15.638846-05:00","updated_at":"2025-12-08T16:39:15.638846-05:00","source_repo":"."}
{"id":"osquery-rust-8en","content_hash":"11235d0cae1d4f78486bf2e4af3789e15afcbf5cf3c9e66a1a6ccb78663ef66a","title":"Task 1: Add util.rs and Plugin enum dispatch tests","description":"","design":"## Goal\nAdd tests for util.rs (2 tests) and plugin/_enums/plugin.rs (12+ tests) to cover the quick wins.\n\n## Context\n- util.rs: 45% coverage, missing None path test\n- plugin/_enums/plugin.rs: 25% coverage, missing Config/Logger dispatch tests\n- Expected coverage gain: +5-7%\n\n## Implementation\n\n### Step 1: Add util.rs tests\nFile: osquery-rust/src/util.rs\n\nAdd #[cfg(test)] module with:\n1. test_ok_or_thrift_err_with_some - verify Some(T) returns Ok(T)\n2. test_ok_or_thrift_err_with_none - verify None returns Err with custom message\n\n### Step 2: Add plugin enum Config dispatch tests\nFile: osquery-rust/src/plugin/_enums/plugin.rs\n\nCreate TestConfigPlugin mock implementing ConfigPlugin trait:\n- name() returns \"test_config\"\n- gen_config() returns Ok(HashMap with test data)\n- gen_pack() returns Ok(\"test pack\")\n\nAdd tests:\n1. test_plugin_config_factory - Plugin::config() creates Config variant\n2. test_plugin_config_name - dispatch to name()\n3. test_plugin_config_registry - dispatch to registry() returns Registry::Config\n4. test_plugin_config_routes - dispatch to routes()\n5. test_plugin_config_ping - dispatch to ping()\n6. test_plugin_config_handle_call - dispatch to handle_call()\n7. test_plugin_config_shutdown - dispatch to shutdown()\n\n### Step 3: Add plugin enum Logger dispatch tests\nCreate TestLoggerPlugin mock implementing LoggerPlugin trait:\n- name() returns \"test_logger\"\n- log_string() returns Ok(())\n\nAdd tests:\n1. test_plugin_logger_factory - Plugin::logger() creates Logger variant\n2. test_plugin_logger_name - dispatch to name()\n3. test_plugin_logger_registry - dispatch to registry() returns Registry::Logger\n4. test_plugin_logger_routes - dispatch to routes()\n5. test_plugin_logger_ping - dispatch to ping()\n6. test_plugin_logger_handle_call - dispatch to handle_call()\n7. test_plugin_logger_shutdown - dispatch to shutdown()\n\n### Step 4: Verify\n- Run cargo test --all-features\n- Run cargo llvm-cov --ignore-filename-regex _osquery\n- Run pre-commit hooks\n\n## Success Criteria\n- [ ] util.rs has 2 new tests (Some/None paths)\n- [ ] plugin.rs has 14 new tests (7 Config + 7 Logger)\n- [ ] util.rs coverage \u003e= 90%\n- [ ] plugin/_enums/plugin.rs coverage \u003e= 90%\n- [ ] All tests pass\n- [ ] Pre-commit hooks pass","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T14:45:21.080148-05:00","updated_at":"2025-12-08T14:51:22.656924-05:00","closed_at":"2025-12-08T14:51:22.656924-05:00","source_repo":"."}
{"id":"osquery-rust-ady","content_hash":"87b1a44013bd1b98787c02b977b574db0a9c3111a1acd8bae19811e20598cba5","title":"Task 1: Update coverage.yml with Docker osquery setup","description":"","design":"## Goal\nModify .github/workflows/coverage.yml to start osquery Docker container and include integration tests in coverage measurement.\n\n## Effort Estimate\n2-4 hours\n\n## Context\n- Epic: osquery-rust-q5d\n- Current workflow only runs unit tests\n- Integration tests need OSQUERY_SOCKET env var pointing to osquery socket\n\n## Implementation\n\n### 1. Study existing patterns\n- .github/workflows/coverage.yml:30-33 - Current coverage command\n- .git/hooks/pre-commit:50-80 - Docker osquery pattern\n- tests/integration_test.rs:47-52 - Socket discovery via env var\n\n### 2. Add Docker setup step (before coverage)\nInsert after 'Install cargo-llvm-cov' step:\n\n```yaml\n- name: Start osquery container\n  run: |\n    mkdir -p /tmp/osquery\n    docker run -d --name osquery \\\n      -v /tmp/osquery:/var/osquery \\\n      osquery/osquery:5.17.0-ubuntu22.04 \\\n      osqueryd --ephemeral --disable_extensions=false \\\n      --extensions_socket=/var/osquery/osquery.em\n    \n    # Wait for socket (30s timeout, 1s poll)\n    for i in {1..30}; do\n      [ -S /tmp/osquery/osquery.em ] \u0026\u0026 echo 'Socket ready' \u0026\u0026 break\n      sleep 1\n    done\n    \n    # Verify socket exists\n    if [ \\! -S /tmp/osquery/osquery.em ]; then\n      echo 'ERROR: osquery socket not found'\n      docker logs osquery\n      exit 1\n    fi\n```\n\n### 3. Update coverage steps with env var\nAdd to 'Generate coverage report' step:\n```yaml\nenv:\n  OSQUERY_SOCKET: /tmp/osquery/osquery.em\n```\n\nAdd same env var to 'Calculate coverage percentage' step.\n\n### 4. Add cleanup step (at end)\n```yaml\n- name: Stop osquery container\n  if: always()\n  run: docker stop osquery || true\n```\n\n### 5. Verify change locally\n```bash\n# Run pre-commit hooks (includes integration tests)\n.git/hooks/pre-commit\n```\n\n## Success Criteria\n- [ ] coverage.yml has Docker setup step after 'Install cargo-llvm-cov'\n- [ ] OSQUERY_SOCKET=/tmp/osquery/osquery.em env var set for 'Generate coverage report' step\n- [ ] OSQUERY_SOCKET=/tmp/osquery/osquery.em env var set for 'Calculate coverage percentage' step\n- [ ] Cleanup step 'Stop osquery container' with if: always()\n- [ ] Workflow runs successfully in GitHub Actions (check Actions tab after push)\n- [ ] Codecov comment shows client.rs/server.rs coverage increased (compare before/after)\n- [ ] Pre-commit hooks pass: .git/hooks/pre-commit exits 0\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO hardcoded socket paths in test code (use OSQUERY_SOCKET env var - already correct)\n- ❌ NO removing --ignore-filename-regex \"_osquery\" (auto-generated code must stay excluded)\n- ❌ NO docker run without -d (must run detached so workflow continues)\n- ❌ NO skipping cleanup step (container must stop even on failure)\n- ❌ NO unpinned Docker image tags (use specific version 5.17.0-ubuntu22.04)\n\n## Key Considerations (SRE REVIEW)\n\n**Edge Case: Docker Image Pull Failure**\n- GitHub Actions runners have Docker pre-installed\n- Image pull could fail on network issues\n- Docker run will fail and show error - acceptable behavior\n- No special handling needed (fail fast is correct)\n\n**Edge Case: Container Startup Failure**\n- osqueryd could fail to start (resource limits, permissions)\n- Socket wait loop handles this (30s timeout, then error)\n- docker logs osquery shows failure reason\n- Current implementation handles this correctly\n\n**Edge Case: Socket Permission Issues**\n- /tmp/osquery created by runner user\n- Docker volume mount preserves permissions\n- osquery creates socket with world-readable perms\n- No special handling needed on Linux runners\n\n**Edge Case: Concurrent Workflow Runs**\n- Container named 'osquery' - could conflict\n- GitHub Actions runs in isolated environments per job\n- No conflict possible - each run gets fresh environment\n\n**Verification: Integration Tests Included**\n- Before: cargo llvm-cov output shows only unit test files\n- After: Should see tests/integration_test.rs exercising client.rs, server.rs\n- Verify: Codecov PR comment shows increased coverage for client.rs (was ~14%)\n- Verify: Look for test_thrift_client_ping, test_query_osquery_info in coverage","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T17:32:22.746044-05:00","updated_at":"2025-12-08T17:36:08.028702-05:00","closed_at":"2025-12-08T17:36:08.028702-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-ady","depends_on_id":"osquery-rust-q5d","type":"parent-child","created_at":"2025-12-08T17:32:29.389788-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-bh2","content_hash":"5c833cd7c3f4b5b6d6bbbf01ad0c5fc0324896f8ec8e995c9b38a7ffe27545ae","title":"Task 3: Add ConfigPlugin, ExtensionResponseEnum, and Logger request type tests","description":"","design":"## Goal\nAdd comprehensive unit tests for remaining plugin types to achieve 60% coverage target before adding coverage infrastructure.\n\n## Effort Estimate\n6-8 hours\n\n## Context\nCompleted Task 1: mockall + 23 TablePlugin tests\nCompleted Task 2: OsqueryClient trait + 7 Server mock tests (40 total tests)\n\nRemaining uncovered areas from epic success criteria:\n- ConfigPlugin gen_config/gen_pack - NO tests\n- ExtensionResponseEnum conversion - NO tests  \n- LoggerPluginWrapper request types - Only features tested, missing 6 request types\n- Handler::handle_call() routing - Partially covered by table tests\n\n## Study Existing Patterns\n- plugin/table/mod.rs tests - TestTable pattern implementing trait\n- plugin/logger/mod.rs tests - TestLogger pattern with features override\n- server.rs tests - MockOsqueryClient usage\n\n## Implementation\n\n### Step 1: Add ConfigPlugin tests (config/mod.rs)\nFile: osquery-rust/src/plugin/config/mod.rs\n\nAdd #[cfg(test)] mod tests at end of file:\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::plugin::OsqueryPlugin;\n    use std::collections::BTreeMap;\n\n    struct TestConfig {\n        config: HashMap\u003cString, String\u003e,\n        packs: HashMap\u003cString, String\u003e,\n        fail_config: bool,\n    }\n\n    impl TestConfig {\n        fn new() -\u003e Self {\n            let mut config = HashMap::new();\n            config.insert(\"main\".to_string(), r#\"{\"options\":{}}\"#.to_string());\n            Self { config, packs: HashMap::new(), fail_config: false }\n        }\n        \n        fn with_pack(mut self, name: \u0026str, content: \u0026str) -\u003e Self {\n            self.packs.insert(name.to_string(), content.to_string());\n            self\n        }\n        \n        fn failing() -\u003e Self {\n            Self { \n                config: HashMap::new(), \n                packs: HashMap::new(), \n                fail_config: true \n            }\n        }\n    }\n\n    impl ConfigPlugin for TestConfig {\n        fn name(\u0026self) -\u003e String { \"test_config\".to_string() }\n        \n        fn gen_config(\u0026self) -\u003e Result\u003cHashMap\u003cString, String\u003e, String\u003e {\n            if self.fail_config {\n                Err(\"Config generation failed\".to_string())\n            } else {\n                Ok(self.config.clone())\n            }\n        }\n        \n        fn gen_pack(\u0026self, name: \u0026str, _value: \u0026str) -\u003e Result\u003cString, String\u003e {\n            self.packs.get(name).cloned().ok_or_else(|| format!(\"Pack '{name}' not found\"))\n        }\n    }\n\n    #[test]\n    fn test_gen_config_returns_config_map() {\n        let config = TestConfig::new();\n        let wrapper = ConfigPluginWrapper::new(config);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"genConfig\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        // Verify success status\n        let status = response.status.as_ref();\n        assert!(status.is_some());\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n        \n        // Verify response contains config data\n        assert!(!response.response.is_empty());\n        let row = response.response.first();\n        assert!(row.is_some());\n        assert!(row.unwrap().contains_key(\"main\"));\n    }\n\n    #[test]\n    fn test_gen_config_failure_returns_error() {\n        let config = TestConfig::failing();\n        let wrapper = ConfigPluginWrapper::new(config);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"genConfig\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        // Verify failure status code 1\n        let status = response.status.as_ref();\n        assert!(status.is_some());\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n        \n        // Verify response contains failure status\n        let row = response.response.first();\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"failure\"));\n    }\n\n    #[test]\n    fn test_gen_pack_returns_pack_content() {\n        let config = TestConfig::new().with_pack(\"security\", r#\"{\"queries\":{}}\"#);\n        let wrapper = ConfigPluginWrapper::new(config);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"genPack\".to_string());\n        request.insert(\"name\".to_string(), \"security\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n        \n        let row = response.response.first();\n        assert!(row.is_some());\n        assert!(row.unwrap().contains_key(\"pack\"));\n    }\n\n    #[test]\n    fn test_gen_pack_not_found_returns_error() {\n        let config = TestConfig::new(); // No packs\n        let wrapper = ConfigPluginWrapper::new(config);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"genPack\".to_string());\n        request.insert(\"name\".to_string(), \"nonexistent\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n        \n        let row = response.response.first();\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"failure\"));\n    }\n\n    #[test]\n    fn test_unknown_action_returns_error() {\n        let config = TestConfig::new();\n        let wrapper = ConfigPluginWrapper::new(config);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"invalidAction\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n    }\n\n    #[test]\n    fn test_config_plugin_registry() {\n        let config = TestConfig::new();\n        let wrapper = ConfigPluginWrapper::new(config);\n        assert_eq!(wrapper.registry(), Registry::Config);\n    }\n\n    #[test]\n    fn test_config_plugin_routes_empty() {\n        let config = TestConfig::new();\n        let wrapper = ConfigPluginWrapper::new(config);\n        assert!(wrapper.routes().is_empty());\n    }\n    \n    #[test]\n    fn test_config_plugin_name() {\n        let config = TestConfig::new();\n        let wrapper = ConfigPluginWrapper::new(config);\n        assert_eq!(wrapper.name(), \"test_config\");\n    }\n}\n```\n\n### Step 2: Add ExtensionResponseEnum tests (_enums/response.rs)\nFile: osquery-rust/src/plugin/_enums/response.rs\n\nAdd #[cfg(test)] mod tests at end of file:\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_first_row(resp: \u0026ExtensionResponse) -\u003e Option\u003c\u0026BTreeMap\u003cString, String\u003e\u003e {\n        resp.response.first()\n    }\n\n    #[test]\n    fn test_success_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::Success().into();\n        \n        // Check status code 0\n        let status = resp.status.as_ref();\n        assert!(status.is_some());\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n        \n        // Check response contains \"status\": \"success\"\n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"success\"));\n    }\n\n    #[test]\n    fn test_success_with_id_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::SuccessWithId(42).into();\n        \n        let status = resp.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n        \n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        let row = row.unwrap();\n        assert_eq!(row.get(\"status\").map(|s| s.as_str()), Some(\"success\"));\n        assert_eq!(row.get(\"id\").map(|s| s.as_str()), Some(\"42\"));\n    }\n\n    #[test]\n    fn test_success_with_code_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::SuccessWithCode(5).into();\n        \n        // Check status code is the custom code\n        let status = resp.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(5));\n        \n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"success\"));\n    }\n\n    #[test]\n    fn test_failure_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::Failure(\"error msg\".to_string()).into();\n        \n        let status = resp.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n        \n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        let row = row.unwrap();\n        assert_eq!(row.get(\"status\").map(|s| s.as_str()), Some(\"failure\"));\n        assert_eq!(row.get(\"message\").map(|s| s.as_str()), Some(\"error msg\"));\n    }\n\n    #[test]\n    fn test_constraint_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::Constraint().into();\n        \n        let status = resp.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n        \n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"constraint\"));\n    }\n\n    #[test]\n    fn test_readonly_response() {\n        let resp: ExtensionResponse = ExtensionResponseEnum::Readonly().into();\n        \n        let status = resp.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(1));\n        \n        let row = get_first_row(\u0026resp);\n        assert!(row.is_some());\n        assert_eq!(row.unwrap().get(\"status\").map(|s| s.as_str()), Some(\"readonly\"));\n    }\n}\n```\n\n### Step 3: Add remaining LoggerPluginWrapper request type tests\nFile: osquery-rust/src/plugin/logger/mod.rs\n\n**Approach**: Create a TrackingLogger that records which methods were called using RefCell\u003cVec\u003cString\u003e\u003e.\n\nAdd to existing tests module:\n```rust\n    use std::cell::RefCell;\n\n    /// Logger that tracks method calls for testing\n    struct TrackingLogger {\n        calls: RefCell\u003cVec\u003cString\u003e\u003e,\n        fail_on: Option\u003cString\u003e,\n    }\n\n    impl TrackingLogger {\n        fn new() -\u003e Self {\n            Self { calls: RefCell::new(Vec::new()), fail_on: None }\n        }\n        \n        fn failing_on(method: \u0026str) -\u003e Self {\n            Self { \n                calls: RefCell::new(Vec::new()), \n                fail_on: Some(method.to_string()) \n            }\n        }\n        \n        fn was_called(\u0026self, method: \u0026str) -\u003e bool {\n            self.calls.borrow().contains(\u0026method.to_string())\n        }\n    }\n\n    impl LoggerPlugin for TrackingLogger {\n        fn name(\u0026self) -\u003e String { \"tracking_logger\".to_string() }\n        \n        fn log_string(\u0026self, _message: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.calls.borrow_mut().push(\"log_string\".to_string());\n            if self.fail_on.as_deref() == Some(\"log_string\") {\n                Err(\"log_string failed\".to_string())\n            } else {\n                Ok(())\n            }\n        }\n        \n        fn log_status(\u0026self, _status: \u0026LogStatus) -\u003e Result\u003c(), String\u003e {\n            self.calls.borrow_mut().push(\"log_status\".to_string());\n            if self.fail_on.as_deref() == Some(\"log_status\") {\n                Err(\"log_status failed\".to_string())\n            } else {\n                Ok(())\n            }\n        }\n        \n        fn log_snapshot(\u0026self, _snapshot: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.calls.borrow_mut().push(\"log_snapshot\".to_string());\n            Ok(())\n        }\n        \n        fn init(\u0026self, _name: \u0026str) -\u003e Result\u003c(), String\u003e {\n            self.calls.borrow_mut().push(\"init\".to_string());\n            Ok(())\n        }\n        \n        fn health(\u0026self) -\u003e Result\u003c(), String\u003e {\n            self.calls.borrow_mut().push(\"health\".to_string());\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_status_log_request_calls_log_status() {\n        let logger = TrackingLogger::new();\n        let wrapper = LoggerPluginWrapper::new(logger);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"status\".to_string());\n        request.insert(\"log\".to_string(), r#\"[{\"s\":1,\"f\":\"test.cpp\",\"i\":42,\"m\":\"test message\"}]\"#.to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n        \n        // Verify log_status was called (via wrapper's internal logger)\n        // Note: wrapper owns logger, so we verify success response\n    }\n\n    #[test]\n    fn test_raw_string_request_calls_log_string() {\n        let logger = TrackingLogger::new();\n        let wrapper = LoggerPluginWrapper::new(logger);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"log\".to_string());\n        request.insert(\"string\".to_string(), \"test log message\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n    }\n\n    #[test]\n    fn test_snapshot_request_calls_log_snapshot() {\n        let logger = TrackingLogger::new();\n        let wrapper = LoggerPluginWrapper::new(logger);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"snapshot\".to_string());\n        request.insert(\"snapshot\".to_string(), r#\"{\"data\":\"snapshot\"}\"#.to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n    }\n\n    #[test]\n    fn test_init_request_calls_init() {\n        let logger = TrackingLogger::new();\n        let wrapper = LoggerPluginWrapper::new(logger);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"init\".to_string());\n        request.insert(\"name\".to_string(), \"test_logger\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n    }\n\n    #[test]\n    fn test_health_request_calls_health() {\n        let logger = TrackingLogger::new();\n        let wrapper = LoggerPluginWrapper::new(logger);\n        \n        let mut request: BTreeMap\u003cString, String\u003e = BTreeMap::new();\n        request.insert(\"action\".to_string(), \"health\".to_string());\n        \n        let response = wrapper.handle_call(request);\n        \n        let status = response.status.as_ref();\n        assert_eq!(status.and_then(|s| s.code), Some(0));\n    }\n```\n\n### Step 4: Verify Handler routing coverage\nHandler::handle_call() routing is adequately covered by:\n- table/mod.rs tests (test_readonly_table_routes_via_handle_call)\n- server_tests.rs tests for registry/routing\n\nNo additional tests needed - existing coverage sufficient.\n\n## Implementation Checklist\n- [ ] config/mod.rs: Create TestConfig struct implementing ConfigPlugin\n- [ ] config/mod.rs: Add test_gen_config_returns_config_map\n- [ ] config/mod.rs: Add test_gen_config_failure_returns_error\n- [ ] config/mod.rs: Add test_gen_pack_returns_pack_content\n- [ ] config/mod.rs: Add test_gen_pack_not_found_returns_error\n- [ ] config/mod.rs: Add test_unknown_action_returns_error\n- [ ] config/mod.rs: Add test_config_plugin_registry\n- [ ] config/mod.rs: Add test_config_plugin_routes_empty\n- [ ] config/mod.rs: Add test_config_plugin_name\n- [ ] _enums/response.rs: Add get_first_row helper\n- [ ] _enums/response.rs: Add test_success_response\n- [ ] _enums/response.rs: Add test_success_with_id_response\n- [ ] _enums/response.rs: Add test_success_with_code_response\n- [ ] _enums/response.rs: Add test_failure_response\n- [ ] _enums/response.rs: Add test_constraint_response\n- [ ] _enums/response.rs: Add test_readonly_response\n- [ ] logger/mod.rs: Add TrackingLogger struct\n- [ ] logger/mod.rs: Add test_status_log_request_calls_log_status\n- [ ] logger/mod.rs: Add test_raw_string_request_calls_log_string\n- [ ] logger/mod.rs: Add test_snapshot_request_calls_log_snapshot\n- [ ] logger/mod.rs: Add test_init_request_calls_init\n- [ ] logger/mod.rs: Add test_health_request_calls_health\n- [ ] Run cargo test --all-features (target: 60+ tests)\n- [ ] Run pre-commit hooks\n\n## Success Criteria\n- [ ] ConfigPlugin has 9 tests: gen_config success/failure, gen_pack success/failure, unknown action, registry, routes, name, ping\n- [ ] ExtensionResponseEnum has 6 tests (one per variant)\n- [ ] LoggerPluginWrapper has 10+ tests covering all request types (features + status + string + snapshot + init + health)\n- [ ] All tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass: .git/hooks/pre-commit\n- [ ] Total tests: ~60 (up from 40)\n- [ ] Verification command: cargo test 2\u003e\u00261 | grep \"test result\" | tail -1\n\n## Key Considerations (ADDED BY SRE REVIEW)\n\n**Edge Case: Empty HashMap from gen_config**\n- What happens if gen_config returns Ok(empty HashMap)?\n- Response will have empty row - verify this is acceptable\n- Add test: test_gen_config_empty_map_returns_empty_response\n\n**Edge Case: Empty Pack Name**\n- What if gen_pack is called with empty name?\n- Default behavior returns \"Pack '' not found\" error\n- Test coverage: test_gen_pack_not_found handles this\n\n**Edge Case: Malformed JSON in Status Log**\n- What if status log JSON is malformed?\n- LoggerPluginWrapper::parse_status_log uses serde_json\n- If malformed: will return empty entries, log_status not called\n- Test coverage: Consider adding test_malformed_status_log_handles_gracefully\n\n**Edge Case: Empty String Messages**\n- log_string(\"\") should work - no special handling needed\n- TrackingLogger tests verify method is called regardless of content\n\n**RefCell Safety in Tests**\n- TrackingLogger uses RefCell for interior mutability\n- Safe in single-threaded test context\n- DO NOT use TrackingLogger in multi-threaded tests\n\n**Response Verification Pattern**\n- All tests use response.status.as_ref().and_then(|s| s.code) pattern\n- Safe: handles None case without unwrap\n- Consistent with existing test patterns in codebase\n\n## Anti-Patterns (from epic + SRE review)\n- ❌ NO tests in separate tests/ directory (inline #[cfg(test)] modules)\n- ❌ NO unwrap/expect/panic in test code (use assert! and .is_some() checks)\n- ❌ NO skipping error path tests (test both success and failure paths)\n- ❌ NO #[allow(dead_code)] on test helpers (tests use them)\n- ❌ NO multi-threaded tests with RefCell (use for single-threaded only)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T14:03:16.287054-05:00","updated_at":"2025-12-08T14:16:38.079811-05:00","closed_at":"2025-12-08T14:16:38.079811-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-bh2","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T14:03:24.599548-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-bh2","depends_on_id":"osquery-rust-jn9","type":"blocks","created_at":"2025-12-08T14:03:25.179084-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-bvh","content_hash":"9c3f61aacf2258a27eeac71fb804a6f2f0793b417df2c2367f3847526fcc49d0","title":"Task 5: Add QueryConstraints parsing tests","description":"","design":"## Goal\nAdd unit tests for QueryConstraints, ConstraintList, Constraint, and Operator types.\n\n## Context\n- Epic osquery-rust-14q success criterion: 'QueryConstraints parsing tested'\n- File: plugin/table/query_constraint.rs\n- Currently has no tests\n\n## Implementation\n\n### Step 1: Add tests module to query_constraint.rs\nAdd `#[cfg(test)] mod tests { ... }` with:\n\n1. **test_constraint_list_creation** - Create ConstraintList with column type and constraints\n2. **test_constraint_with_equals_operator** - Create Constraint with Equals op\n3. **test_constraint_with_comparison_operators** - Test GreaterThan, LessThan, etc.\n4. **test_query_constraints_map** - Test HashMap\u003cString, ConstraintList\u003e usage\n5. **test_operator_variants** - Verify all Operator enum variants exist\n\n### Step 2: Make structs testable\n- May need to add constructors or make fields pub(crate) for testing\n- Follow existing patterns in codebase (no unwrap/expect/panic)\n\n## Success Criteria\n- [ ] 5+ tests for query_constraint.rs module\n- [ ] All Operator variants tested\n- [ ] ConstraintList creation tested\n- [ ] Tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T14:24:24.903523-05:00","updated_at":"2025-12-08T14:26:19.593145-05:00","closed_at":"2025-12-08T14:26:19.593145-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-bvh","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T14:24:32.013358-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-dv9","content_hash":"9eea1900a7c756defbbcabd3792aaeb5b2a9fcc5b957bfd33e3b30f0a9b9635b","title":"Task 4: Add test_table_plugin_end_to_end integration test","description":"","design":"## Goal\nAdd integration test that registers a table extension, then queries it via osquery to verify the full end-to-end flow.\n\n## Effort Estimate\n2-4 hours\n\n## Context\nCompleted:\n- bd-p6i: OsqueryClient trait now has query() method\n- bd-81n: test_query_osquery_info proves query() works\n- bd-p85: test_server_lifecycle proves Server registration works\n\nThis test combines both: register extension table, then query it through osquery.\n\n## Implementation\n\n### 1. Study how osquery queries extension tables\n- Extension registers table with Server.register_plugin()\n- Server.run() registers with osquery via register_extension RPC\n- osquery can then query the table via SQL\n- Need to query from ANOTHER client connected to osquery (not the server)\n\n### 2. Write test_table_plugin_end_to_end\nAdd to tests/integration_test.rs:\n\n```rust\n#[test]\nfn test_table_plugin_end_to_end() {\n    use osquery_rust_ng::plugin::{\n        ColumnDef, ColumnOptions, ColumnType, ReadOnlyTable, TablePlugin,\n    };\n    use osquery_rust_ng::{\n        ExtensionPluginRequest, ExtensionResponse, ExtensionStatus, \n        OsqueryClient, Server, ThriftClient,\n    };\n    use std::collections::BTreeMap;\n    use std::thread;\n\n    // Create test table that returns known data\n    struct TestEndToEndTable;\n\n    impl ReadOnlyTable for TestEndToEndTable {\n        fn name(\u0026self) -\u003e String {\n            \"test_e2e_table\".to_string()\n        }\n\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e {\n            vec\\![\n                ColumnDef::new(\"id\", ColumnType::Integer, ColumnOptions::DEFAULT),\n                ColumnDef::new(\"name\", ColumnType::Text, ColumnOptions::DEFAULT),\n            ]\n        }\n\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            let mut row = BTreeMap::new();\n            row.insert(\"id\".to_string(), \"42\".to_string());\n            row.insert(\"name\".to_string(), \"test_value\".to_string());\n            \n            ExtensionResponse::new(\n                ExtensionStatus {\n                    code: Some(0),\n                    message: Some(\"OK\".to_string()),\n                    uuid: None,\n                },\n                vec\\![row],\n            )\n        }\n\n        fn shutdown(\u0026self) {}\n    }\n\n    let socket_path = get_osquery_socket();\n    eprintln\\!(\"Using osquery socket: {}\", socket_path);\n\n    // Create and start server with test table\n    let mut server = Server::new(Some(\"test_e2e\"), \u0026socket_path)\n        .expect(\"Failed to create Server\");\n    \n    let plugin = TablePlugin::from_readonly_table(TestEndToEndTable);\n    server.register_plugin(plugin);\n\n    let stop_handle = server.get_stop_handle();\n\n    let server_thread = thread::spawn(move || {\n        server.run().expect(\"Server run failed\");\n    });\n\n    // Wait for extension to register\n    std::thread::sleep(Duration::from_secs(2));\n\n    // Query the table through osquery using a separate client\n    let mut client = ThriftClient::new(\u0026socket_path, Default::default())\n        .expect(\"Failed to create query client\");\n    \n    let result = client.query(\"SELECT * FROM test_e2e_table\".to_string());\n    \n    // Stop server before assertions (cleanup)\n    stop_handle.stop();\n    server_thread.join().expect(\"Server thread panicked\");\n\n    // Verify query results\n    let response = result.expect(\"Query should succeed\");\n    let status = response.status.expect(\"Should have status\");\n    assert_eq\\!(status.code, Some(0), \"Query should return success\");\n    \n    let rows = response.response.expect(\"Should have rows\");\n    assert_eq\\!(rows.len(), 1, \"Should have exactly one row\");\n    \n    let row = rows.first().expect(\"Should have first row\");\n    assert_eq\\!(row.get(\"id\"), Some(\u0026\"42\".to_string()));\n    assert_eq\\!(row.get(\"name\"), Some(\u0026\"test_value\".to_string()));\n\n    eprintln\\!(\"SUCCESS: End-to-end table query returned expected data\");\n}\n```\n\n### 3. Run test locally\n```bash\ncargo test --test integration_test test_table_plugin_end_to_end\n```\n\n## Success Criteria\n- [ ] test_table_plugin_end_to_end exists in tests/integration_test.rs\n- [ ] Test compiles without errors\n- [ ] Extension table registers successfully with osquery\n- [ ] Query SELECT * FROM test_e2e_table returns expected row\n- [ ] Row contains id=42 and name=test_value\n- [ ] Test passes when osquery available\n- [ ] Test FAILS when osquery unavailable\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE REVIEW)\n\n**Edge Case: Table Not Found**\n- If extension doesn't register in time, osquery returns \"table not found\"\n- 2 second sleep should be sufficient based on test_server_lifecycle\n- If flaky, increase to 3 seconds\n\n**Edge Case: Query Client vs Server**\n- Server uses one Thrift connection for registration\n- Query client needs separate connection to same socket\n- Both ThriftClient instances connect to osquery, not to each other\n\n**Edge Case: Test Isolation**\n- Use unique extension name \"test_e2e\"\n- Use unique table name \"test_e2e_table\"\n- Cleanup happens via stop_handle.stop()\n\n**Edge Case: Server Registration Failure**\n- If server.run() fails, thread will panic with expect()\n- This is correct for integration test - surfaces infra issues\n- Server thread panic will be caught by join().expect()\n\n**Edge Case: Query Returns Empty**\n- If table registered but generate() not called, rows would be empty\n- Test explicitly asserts rows.len() == 1 to catch this\n- Also asserts specific row values as defense in depth\n\n**Edge Case: Race Condition on Registration**\n- server.run() calls register_extension internally\n- 2 second delay allows osquery to acknowledge\n- If flaky: consider polling osquery_extensions table for our extension UUID\n\n**Reference Implementation**\n- test_server_lifecycle (bd-p85) established the Server pattern\n- test_query_osquery_info (bd-81n) established the query pattern\n- This test combines both patterns\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO mocking osquery - this is integration test\n- ❌ NO skipping when osquery unavailable - must fail\n- ❌ NO Docker in test code - native osquery only\n- ❌ NO unwrap() - use expect() with descriptive message\n- ❌ NO assertions before cleanup - stop server first to avoid hanging on failure","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T17:10:44.444142-05:00","updated_at":"2025-12-08T17:18:28.541051-05:00","closed_at":"2025-12-08T17:18:28.541051-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-dv9","depends_on_id":"osquery-rust-86j","type":"parent-child","created_at":"2025-12-08T17:10:50.496281-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-dv9","depends_on_id":"osquery-rust-p85","type":"blocks","created_at":"2025-12-08T17:10:51.049334-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-jn9","content_hash":"d1f7da8a4cbb781eb5b28c1c8ad0edf310227a9019dbf60e09f63bbdfb809211","title":"Task 2: Extract OsqueryClient trait and add Server tests","description":"","design":"## Goal\nExtract OsqueryClient trait from Client struct to enable mocking osquery daemon in tests. Then add Server tests that use MockOsqueryClient.\n\n## Context\nCompleted osquery-rust-7bs: Added mockall, 23 table plugin tests. \nNow need to make Server testable without real osquery daemon.\n\n## Effort Estimate\n6-8 hours\n\n## Study Existing Patterns\n- client.rs:7-87 - Current Client struct with concrete UnixStream\n- server.rs:67-414 - Server struct uses Client directly\n- server_tests.rs - Existing socket mock patterns\n- Current Client implements TExtensionManagerSyncClient and TExtensionSyncClient traits\n\n## Implementation\n\n### Step 1: Extract OsqueryClient trait from Client\nFile: osquery-rust/src/client.rs\n\nThe trait should match the methods Server actually uses. Looking at server.rs, Server uses:\n- register_extension() (via TExtensionManagerSyncClient)\n- deregister_extension() (via TExtensionManagerSyncClient)  \n- ping() (via TExtensionSyncClient)\n\nCreate custom trait with these methods:\n```rust\nuse crate::_osquery::{ExtensionRegistry, ExtensionRouteUUID, ExtensionStatus, InternalExtensionInfo};\n\n/// Trait for osquery daemon communication - enables mocking in tests\npub trait OsqueryClient: Send {\n    fn register_extension(\n        \u0026mut self,\n        info: InternalExtensionInfo,\n        registry: ExtensionRegistry,\n    ) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n    \n    fn deregister_extension(\u0026mut self, uuid: ExtensionRouteUUID) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n    \n    fn ping(\u0026mut self) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n}\n```\n\nNOTE: Use thrift::Result\u003cT\u003e not Result\u003cT, Error\u003e to match existing return types.\n\n### Step 2: Rename Client to ThriftClient, implement trait\n```rust\n/// Production implementation using Thrift over Unix sockets\npub struct ThriftClient {\n    client: osquery::ExtensionManagerSyncClient\u003c\n        TBinaryInputProtocol\u003cUnixStream\u003e,\n        TBinaryOutputProtocol\u003cUnixStream\u003e,\n    \u003e,\n}\n\nimpl ThriftClient {\n    pub fn new(socket_path: \u0026str, timeout: Duration) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        let socket_tx = UnixStream::connect(socket_path)?;\n        let socket_rx = socket_tx.try_clone()?;\n        let in_proto = TBinaryInputProtocol::new(socket_tx, true);\n        let out_proto = TBinaryOutputProtocol::new(socket_rx, true);\n        Ok(ThriftClient {\n            client: osquery::ExtensionManagerSyncClient::new(in_proto, out_proto),\n        })\n    }\n}\n\nimpl OsqueryClient for ThriftClient {\n    fn register_extension(\u0026mut self, info: InternalExtensionInfo, registry: ExtensionRegistry) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionManagerSyncClient::register_extension(\u0026mut self.client, info, registry)\n    }\n    \n    fn deregister_extension(\u0026mut self, uuid: ExtensionRouteUUID) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionManagerSyncClient::deregister_extension(\u0026mut self.client, uuid)\n    }\n    \n    fn ping(\u0026mut self) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionSyncClient::ping(\u0026mut self.client)\n    }\n}\n\n// Backwards compatibility - CRITICAL\npub type Client = ThriftClient;\n```\n\n### Step 3: Keep existing TExtension*SyncClient impls\nKeep the existing impls of TExtensionManagerSyncClient and TExtensionSyncClient for ThriftClient - they may be used elsewhere.\n\n### Step 4: Update Server to be generic over client type\nFile: osquery-rust/src/server.rs\n\n```rust\npub struct Server\u003cP: OsqueryPlugin + Clone + Send + Sync + 'static, C: OsqueryClient = ThriftClient\u003e {\n    name: String,\n    socket_path: String,\n    client: C,\n    plugins: Vec\u003cP\u003e,\n    // ... rest unchanged\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static, C: OsqueryClient\u003e Server\u003cP, C\u003e {\n    // Existing new() becomes specific to ThriftClient\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static\u003e Server\u003cP, ThriftClient\u003e {\n    pub fn new(name: Option\u003c\u0026str\u003e, socket_path: \u0026str) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        // ... existing implementation\n    }\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static, C: OsqueryClient\u003e Server\u003cP, C\u003e {\n    /// Constructor for testing with mock client\n    pub fn with_client(name: Option\u003c\u0026str\u003e, socket_path: \u0026str, client: C) -\u003e Self {\n        Server {\n            name: name.unwrap_or(clap::crate_name!()).to_string(),\n            socket_path: socket_path.to_string(),\n            client,\n            plugins: Vec::new(),\n            ping_interval: DEFAULT_PING_INTERVAL,\n            uuid: None,\n            started: false,\n            shutdown_flag: Arc::new(AtomicBool::new(false)),\n            listener_thread: None,\n            listen_path: None,\n        }\n    }\n}\n```\n\n### Step 5: Add MockOsqueryClient and Server tests\nFile: osquery-rust/src/server.rs (add to existing #[cfg(test)] section or create new)\n\n```rust\n#[cfg(test)]\nmod client_mock_tests {\n    use super::*;\n    use crate::client::OsqueryClient;\n    use mockall::mock;\n    \n    mock! {\n        pub TestClient {}\n        impl OsqueryClient for TestClient {\n            fn register_extension(\n                \u0026mut self,\n                info: osquery::InternalExtensionInfo,\n                registry: osquery::ExtensionRegistry,\n            ) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n            \n            fn deregister_extension(\u0026mut self, uuid: osquery::ExtensionRouteUUID) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n            \n            fn ping(\u0026mut self) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n        }\n    }\n    \n    #[test]\n    fn test_server_with_mock_client_creation() {\n        let mock_client = MockTestClient::new();\n        let server: Server\u003cPlugin, MockTestClient\u003e = Server::with_client(\n            Some(\"test_ext\"),\n            \"/tmp/test.sock\",\n            mock_client,\n        );\n        assert_eq!(server.name, \"test_ext\");\n    }\n    \n    #[test]\n    fn test_server_register_plugin() {\n        use crate::plugin::table::{TablePlugin, ReadOnlyTable, ColumnDef, ColumnType};\n        use crate::plugin::table::column_def::ColumnOptions;\n        \n        // Create simple test table\n        struct TestTable;\n        impl ReadOnlyTable for TestTable {\n            fn name(\u0026self) -\u003e String { \"test\".to_string() }\n            fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { \n                vec![ColumnDef::new(\"col\", ColumnType::Text, ColumnOptions::DEFAULT)]\n            }\n            fn generate(\u0026self, _: crate::ExtensionPluginRequest) -\u003e crate::ExtensionResponse {\n                crate::ExtensionResponse::new(osquery::ExtensionStatus::default(), vec![])\n            }\n            fn shutdown(\u0026self) {}\n        }\n        \n        let mock_client = MockTestClient::new();\n        let mut server: Server\u003cPlugin, MockTestClient\u003e = Server::with_client(\n            Some(\"test\"),\n            \"/tmp/test.sock\",\n            mock_client,\n        );\n        \n        let plugin = Plugin::table(TestTable);\n        server.register_plugin(plugin);\n        assert_eq!(server.plugins.len(), 1);\n    }\n}\n```\n\n## Implementation Checklist\n- [ ] client.rs:1-10 - Add OsqueryClient trait definition\n- [ ] client.rs:7-12 - Rename struct Client to ThriftClient\n- [ ] client.rs:14-27 - Update impl block to impl ThriftClient (keep same new() signature)\n- [ ] client.rs - Add impl OsqueryClient for ThriftClient\n- [ ] client.rs - Add type alias: pub type Client = ThriftClient;\n- [ ] client.rs - Keep existing TExtension*SyncClient impls for ThriftClient\n- [ ] lib.rs - Export OsqueryClient trait: pub use client::OsqueryClient;\n- [ ] server.rs:67 - Update Server struct: Server\u003cP, C: OsqueryClient = ThriftClient\u003e\n- [ ] server.rs:83 - Split impl blocks: one for Server\u003cP, ThriftClient\u003e, one generic\n- [ ] server.rs - Add Server::with_client() constructor\n- [ ] server.rs - Update all methods to use C instead of Client where needed\n- [ ] server.rs tests - Add MockTestClient using mockall::mock!\n- [ ] server.rs tests - test_server_with_mock_client_creation()\n- [ ] server.rs tests - test_server_register_plugin()\n- [ ] Verify cargo test --all-features passes\n- [ ] Verify pre-commit hooks pass\n\n## Success Criteria\n- [ ] OsqueryClient trait defined in client.rs with register_extension, deregister_extension, ping\n- [ ] ThriftClient struct (renamed from Client) implements OsqueryClient\n- [ ] pub type Client = ThriftClient; exists for backwards compat\n- [ ] Server\u003cP, C: OsqueryClient = ThriftClient\u003e compiles\n- [ ] Server::with_client() allows injecting mock client\n- [ ] MockTestClient generated via mockall::mock!\n- [ ] 2+ Server tests with mock client passing\n- [ ] Existing server_tests.rs (5 tests) still pass\n- [ ] All 38+ tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass (clippy, fmt)\n\n## Key Considerations (SRE REVIEW)\n\n**Error Type Compatibility:**\n- OsqueryClient trait returns thrift::Result\u003cT\u003e, NOT std::io::Error\n- This matches existing TExtension*SyncClient trait signatures\n- Server::new() returns Result\u003c_, std::io::Error\u003e (unchanged)\n- Server::with_client() returns Self directly (no Result - client already constructed)\n\n**Backwards Compatibility:**\n- Client type alias MUST exist: pub type Client = ThriftClient;\n- Client::new() signature MUST remain: fn new(socket_path: \u0026str, timeout: Duration) -\u003e Result\u003cSelf, std::io::Error\u003e\n- Server::new() MUST continue to work unchanged\n- Existing server_tests.rs MUST pass unchanged\n\n**Thread Safety:**\n- OsqueryClient requires Send (client moves to server thread)\n- ThriftClient is Send because UnixStream is Send\n- MockTestClient from mockall is Send by default\n\n**Generic Type Propagation:**\n- Server\u003cP\u003e becomes Server\u003cP, C = ThriftClient\u003e\n- Handler\u003cP\u003e may need C generic if it accesses client directly\n- Check all impl blocks and update type parameters\n\n**Edge Case: Existing todo!() in client.rs:**\n- client.rs:80 has todo!() in call() method\n- This is in TExtensionSyncClient impl, NOT OsqueryClient trait\n- OsqueryClient only exposes register_extension, deregister_extension, ping\n- todo!() remains but is never called through our trait (safe to leave)\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO breaking Client::new() API signature\n- ❌ NO changing Client::new() return type\n- ❌ NO unwrap/expect in test or production code\n- ❌ NO removing existing server_tests.rs tests\n- ❌ NO removing TExtension*SyncClient impls (may be used elsewhere)\n- ❌ NO using std::io::Error where thrift::Result expected","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T12:34:12.282838-05:00","updated_at":"2025-12-08T12:57:31.32873-05:00","closed_at":"2025-12-08T12:57:31.32873-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-jn9","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T12:34:19.760684-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-jn9","depends_on_id":"osquery-rust-7bs","type":"blocks","created_at":"2025-12-08T12:34:20.300833-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-p6i","content_hash":"f2fafebe06e47aa4b46dff19804c73e3deaee854391b107ac4b66a9d9119af0e","title":"Task 1: Expand OsqueryClient trait with query methods","description":"","design":"## Goal\nAdd query() and get_query_columns() methods to the OsqueryClient trait, enabling integration tests to execute SQL queries against osquery.\n\n## Effort Estimate\n2-4 hours\n\n## Implementation\n\n### 1. Study existing code\n- client.rs:13-29 - Current OsqueryClient trait definition\n- client.rs:58-89 - TExtensionManagerSyncClient impl with query() already implemented\n- client.rs:82-88 - Existing query() and get_query_columns() implementations\n\n### 2. Write tests first (TDD)\nAdd to server.rs tests (unit tests with MockOsqueryClient):\n- test_mock_client_query() - verify mock can implement query(), returns expected ExtensionResponse\n- test_mock_client_get_query_columns() - verify mock can implement get_query_columns()\n\n### 3. Implementation checklist\n- [ ] client.rs:13-29 - Add to OsqueryClient trait:\n      fn query(\u0026mut self, sql: String) -\u003e thrift::Result\u003ccrate::ExtensionResponse\u003e;\n- [ ] client.rs:13-29 - Add to OsqueryClient trait:\n      fn get_query_columns(\u0026mut self, sql: String) -\u003e thrift::Result\u003ccrate::ExtensionResponse\u003e;\n- [ ] client.rs - Implement OsqueryClient::query for ThriftClient:\n      fn query(\u0026mut self, sql: String) -\u003e thrift::Result\u003ccrate::ExtensionResponse\u003e {\n          osquery::TExtensionManagerSyncClient::query(self, sql)\n      }\n- [ ] client.rs - Implement OsqueryClient::get_query_columns for ThriftClient (same pattern)\n- [ ] server.rs tests - Add mock tests for new trait methods\n\n## Success Criteria\n- [ ] OsqueryClient trait has query(\u0026mut self, sql: String) -\u003e thrift::Result\u003cExtensionResponse\u003e\n- [ ] OsqueryClient trait has get_query_columns(\u0026mut self, sql: String) -\u003e thrift::Result\u003cExtensionResponse\u003e\n- [ ] ThriftClient implements the new methods (delegates to TExtensionManagerSyncClient)\n- [ ] MockOsqueryClient can mock the new methods (automock generates them automatically)\n- [ ] All existing tests pass: cargo test --lib\n- [ ] Pre-commit hooks pass: .git/hooks/pre-commit\n- [ ] Clippy clean: cargo clippy --all-features -- -D warnings\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO implementing query() as standalone method (must be part of OsqueryClient trait for mockability)\n- ❌ NO re-exporting TExtensionManagerSyncClient (keep _osquery pub(crate))\n- ❌ NO changing the Thrift return type (must stay thrift::Result\u003cExtensionResponse\u003e)\n- ❌ NO adding SQL validation (osquery handles validation, we just pass through)\n\n## Key Considerations (SRE Review)\n\n**Edge Case: Empty SQL String**\n- Pass through to osquery - osquery will return error status\n- Do NOT validate SQL in client (osquery handles this)\n- Test should verify empty SQL returns error from osquery\n\n**Edge Case: Invalid SQL Syntax**\n- Pass through to osquery - osquery returns error in ExtensionStatus\n- Client responsibility is transport, not validation\n- Test should verify error status is properly propagated\n\n**Edge Case: osquery Returns Error Status**\n- ExtensionResponse.status.code will be non-zero\n- Thrift Result is Ok() even when osquery returns error\n- This is correct - transport succeeded, query failed\n- Integration tests will verify error handling\n\n**Trait Design Consideration**\n- query() takes String not \u0026str for consistency with Thrift-generated code\n- Return type uses crate::ExtensionResponse (re-exported from _osquery)\n- This maintains encapsulation while enabling public API\n\n**Reference Implementation**\n- ping() in OsqueryClient trait (client.rs:28) follows same pattern\n- Delegates to TExtensionSyncClient::ping() implementation","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T16:39:32.218645-05:00","updated_at":"2025-12-08T16:44:52.884228-05:00","closed_at":"2025-12-08T16:44:52.884228-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-p6i","depends_on_id":"osquery-rust-86j","type":"parent-child","created_at":"2025-12-08T16:39:39.972928-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-p85","content_hash":"95ae39d9a8599b91cdfd3b0321c865a7c7147707383b1ea32b7ad8714d20ee05","title":"Task 3: Add test_server_lifecycle integration test","description":"","design":"## Goal\nAdd integration test for full Server lifecycle: register extension → run → stop → deregister.\n\n## Effort Estimate\n4-6 hours\n\n## Context\nCompleted bd-81n: test_query_osquery_info now passes.\nEpic bd-86j requires test_server_lifecycle() for Success Criteria.\n\n## Implementation\n\n### 1. Study Server registration flow\n- server.rs:93-96 - Server::new(name: Option\u003c\u0026str\u003e, socket_path: \u0026str) -\u003e Result\u003cSelf, Error\u003e\n- server.rs:142-144 - Server.register_plugin(\u0026mut self, plugin: P) -\u003e \u0026Self\n- ReadOnlyTable trait uses \u0026self methods (not static)\n\n### 2. Write test (following existing pattern)\nAdd to tests/integration_test.rs:\n\n```rust\n#[test]\nfn test_server_lifecycle() {\n    use osquery_rust_ng::Server;\n    use osquery_rust_ng::plugin::table::{ReadOnlyTable, ColumnDef, ColumnType, column_def::ColumnOptions};\n    use osquery_rust_ng::{ExtensionPluginRequest, ExtensionResponse, ExtensionStatus};\n    use std::collections::BTreeMap;\n\n    // Create a simple test table\n    struct TestLifecycleTable;\n\n    impl ReadOnlyTable for TestLifecycleTable {\n        fn name(\u0026self) -\u003e String {\n            \"test_lifecycle_table\".to_string()\n        }\n\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e {\n            vec![ColumnDef::new(\"id\", ColumnType::Text, ColumnOptions::DEFAULT)]\n        }\n\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            ExtensionResponse::new(\n                ExtensionStatus {\n                    code: Some(0),\n                    message: Some(\"OK\".to_string()),\n                    uuid: None,\n                },\n                vec![],\n            )\n        }\n\n        fn shutdown(\u0026self) {}\n    }\n\n    let socket_path = get_osquery_socket();\n    eprintln!(\"Using osquery socket: {}\", socket_path);\n\n    // Create server - Server::new returns Result\n    let mut server = Server::new(Some(\"test_lifecycle\"), \u0026socket_path)\n        .expect(\"Failed to create Server\");\n\n    // Register test table\n    server.register_plugin(TestLifecycleTable);\n\n    // Start server (registers extension with osquery)\n    let handle = server.start().expect(\"Server should start and register\");\n\n    // Give osquery time to acknowledge registration\n    std::thread::sleep(std::time::Duration::from_secs(1));\n\n    // Stop server (deregisters extension from osquery)\n    handle.stop().expect(\"Server should stop and deregister\");\n\n    eprintln!(\"SUCCESS: Server lifecycle completed (register → run → stop)\");\n}\n```\n\n### 3. Run test locally\n```bash\ncargo test --test integration_test test_server_lifecycle\n```\n\n## Success Criteria\n- [ ] test_server_lifecycle exists in tests/integration_test.rs\n- [ ] Test compiles without errors\n- [ ] Server::new() succeeds (returns Ok)\n- [ ] server.start() succeeds (returns Ok with handle)\n- [ ] handle.stop() succeeds (returns Ok)\n- [ ] Test passes when osquery socket available\n- [ ] Test FAILS when osquery unavailable\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE REVIEW)\n\n**Edge Case: Server::new Connection Failure**\n- Server::new connects to osquery socket immediately\n- If socket doesn't exist, returns Err - test panics with expect()\n- This is correct behavior for integration test\n\n**Edge Case: Registration Failure**\n- If osquery rejects registration, start() returns Err\n- Test panics with expect() - correct for integration test\n- Osquery may reject if extension name conflicts\n\n**Edge Case: Test Isolation**\n- Use unique extension name \"test_lifecycle\" \n- Use unique table name \"test_lifecycle_table\"\n- Avoid conflicts with other tests running in parallel\n- Pre-commit hook runs tests sequentially, so no concurrency issue\n\n**Reference Implementation**\n- Study TestReadOnlyTable in plugin/table/mod.rs:302-347\n- Follow same pattern for trait implementation\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO mocking osquery - this is integration test\n- ❌ NO skipping when osquery unavailable - must fail to surface infra issues\n- ❌ NO Docker in test code - native osquery only\n- ❌ NO unwrap() - use expect() with descriptive message","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T16:54:23.926028-05:00","updated_at":"2025-12-08T17:06:10.758015-05:00","closed_at":"2025-12-08T17:06:10.758015-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-p85","depends_on_id":"osquery-rust-86j","type":"parent-child","created_at":"2025-12-08T16:54:30.476669-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-p85","depends_on_id":"osquery-rust-81n","type":"blocks","created_at":"2025-12-08T16:54:32.175047-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-q5d","content_hash":"e8e76504ce790072704f57857d1dd28124b371111e5fcd0cbf59d1bf7fc6c06b","title":"Epic: Add Integration Test Coverage to CI","description":"","design":"## Requirements (IMMUTABLE)\n- Modify .github/workflows/coverage.yml to include integration tests in coverage measurement\n- Start osquery Docker container before running coverage\n- Set OSQUERY_SOCKET environment variable for test discovery\n- Clean up container after coverage run (even on failure)\n- Provide local convenience script/command for developers to run coverage with integration tests\n- Coverage badge reflects combined unit + integration test coverage\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] CI coverage workflow runs integration tests (5 tests in tests/integration_test.rs)\n- [ ] Coverage report includes client.rs, server.rs paths exercised by integration tests\n- [ ] Docker container starts and socket is available within 30 seconds\n- [ ] Container cleanup runs even if tests fail (if: always())\n- [ ] Local command exists: make coverage or cargo xtask coverage or script\n- [ ] Coverage percentage increases after change (integration tests add coverage)\n- [ ] All existing CI checks still pass\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO skipping integration tests in coverage (defeats purpose: must include all tests)\n- ❌ NO hardcoded socket paths in test code (flexibility: use OSQUERY_SOCKET env var)\n- ❌ NO removing existing coverage exclusions (consistency: _osquery regex must remain)\n- ❌ NO separate coverage jobs for unit vs integration (simplicity: single combined report)\n- ❌ NO coverage threshold enforcement yet (scope: badge tracking only for now)\n\n## Approach\nExtend existing coverage.yml workflow with Docker setup steps. Start osquery container with volume-mounted socket directory, wait for socket availability, run cargo llvm-cov with OSQUERY_SOCKET env var set, then cleanup. Add local script for developer convenience.\n\n## Architecture\n- .github/workflows/coverage.yml: Add Docker setup, env var, cleanup steps\n- scripts/coverage.sh OR Makefile target: Local convenience command\n- No changes to integration test code (already uses OSQUERY_SOCKET env var)\n\n## Design Rationale\n### Problem\nCurrent CI coverage only measures unit tests. Integration tests exercise critical paths (client.rs query(), server.rs lifecycle, plugin dispatch) that are not reflected in coverage metrics.\n\n### Research Findings\n**Codebase:**\n- .github/workflows/coverage.yml:30-33 - Current coverage runs --workspace (unit tests only)\n- tests/integration_test.rs:47-52 - Tests check OSQUERY_SOCKET env var first\n- .git/hooks/pre-commit:36-150 - Docker pattern for osquery already exists\n\n**External:**\n- cargo-llvm-cov docs - --workspace includes tests/ directory automatically\n- Integration tests are in-process (no subprocess complexity)\n\n### Approaches Considered\n1. **Use cargo llvm-cov with Docker setup** ✓\n   - Pros: Simple, matches existing workflow, in-process tests work directly\n   - Cons: Requires Docker in CI (already available on ubuntu-latest)\n   - **Chosen because:** Minimal changes, consistent with existing patterns\n\n2. **Use show-env for manual instrumentation**\n   - Pros: Maximum control\n   - Cons: More complex, overkill for in-process tests\n   - **Rejected because:** Unnecessary complexity\n\n3. **Separate coverage jobs merged with grcov**\n   - Pros: Flexibility\n   - Cons: New dependency, complex merge step\n   - **Rejected because:** Overkill for this use case\n\n### Scope Boundaries\n**In scope:**\n- CI workflow changes for integration test coverage\n- Local developer convenience command\n- Docker container lifecycle management\n\n**Out of scope (deferred/never):**\n- Coverage threshold enforcement (defer to future epic)\n- Per-file coverage requirements (not needed)\n- Coverage for _osquery generated code (intentionally excluded)\n\n### Open Questions\n- Script location: scripts/coverage.sh vs Makefile vs justfile? (decide during implementation based on existing patterns)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-08T17:32:04.114838-05:00","updated_at":"2025-12-08T17:32:04.114838-05:00","source_repo":"."}
{"id":"osquery-rust-q5d.3","content_hash":"d071a18e2e72936e9d5aa17a014b41af53dc08569a1b39d13f35f1d312956f31","title":"Task 2: Add local coverage convenience script","description":"","design":"## Goal\nCreate a local convenience script for developers to run coverage with integration tests, mirroring the CI workflow.\n\n## Effort Estimate\n1-2 hours\n\n## Context\n- Epic: osquery-rust-q5d\n- Task 1 added Docker osquery setup to CI coverage workflow\n- User explicitly requested \"make a command that does it for me though\"\n- This enables local development verification before pushing\n\n## Implementation\n\n### 1. Study existing patterns\n- .github/workflows/coverage.yml:30-51 - Docker osquery setup\n- .github/workflows/coverage.yml:52-67 - Coverage command with OSQUERY_SOCKET\n- No existing Makefile or scripts/ in repo\n\n### 2. Create scripts/coverage.sh\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# Coverage script with Docker osquery for integration tests\n# Usage: ./scripts/coverage.sh [--html]\n\nOSQUERY_IMAGE=\"osquery/osquery:5.17.0-ubuntu22.04\"\nSOCKET_DIR=\"/tmp/osquery-coverage\"\nCONTAINER_NAME=\"osquery-coverage\"\n\ncleanup() {\n    docker stop \"$CONTAINER_NAME\" 2\u003e/dev/null || true\n    docker rm \"$CONTAINER_NAME\" 2\u003e/dev/null || true\n    rm -rf \"$SOCKET_DIR\"\n}\n\ntrap cleanup EXIT\n\n# Start fresh\ncleanup\n\n# Create socket directory\nmkdir -p \"$SOCKET_DIR\"\n\necho \"Starting osquery container...\"\ndocker run -d --name \"$CONTAINER_NAME\" \\\n    -v \"$SOCKET_DIR:/var/osquery\" \\\n    \"$OSQUERY_IMAGE\" \\\n    osqueryd --ephemeral --disable_extensions=false \\\n    --extensions_socket=/var/osquery/osquery.em\n\n# Wait for socket (30s timeout)\necho \"Waiting for osquery socket...\"\nfor i in {1..30}; do\n    if [ -S \"$SOCKET_DIR/osquery.em\" ]; then\n        echo \"Socket ready\"\n        break\n    fi\n    sleep 1\ndone\n\nif [ ! -S \"$SOCKET_DIR/osquery.em\" ]; then\n    echo \"ERROR: osquery socket not found after 30s\"\n    docker logs \"$CONTAINER_NAME\"\n    exit 1\nfi\n\nexport OSQUERY_SOCKET=\"$SOCKET_DIR/osquery.em\"\n\necho \"Running coverage...\"\nif [[ \"${1:-}\" == \"--html\" ]]; then\n    cargo llvm-cov --all-features --workspace --html --ignore-filename-regex \"_osquery\"\n    echo \"HTML report: target/llvm-cov/html/index.html\"\nelse\n    cargo llvm-cov --all-features --workspace --ignore-filename-regex \"_osquery\"\nfi","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T17:38:07.266245-05:00","updated_at":"2025-12-08T17:39:52.657393-05:00","closed_at":"2025-12-08T17:39:52.657393-05:00","source_repo":"."}
{"id":"osquery-rust-x7l","content_hash":"86d68106d46f6331c0d9ac968284f98ac46ffaa0e863bd7b6ad83e6a5978adab","title":"Task 3a: Set up testcontainers infrastructure","description":"","design":"## Goal\nSet up testcontainers-rs infrastructure for Docker-based osquery integration tests.\n\n## Effort Estimate\n2-3 hours\n\n## Implementation Checklist\n\n### Step 1: Add testcontainers dependency\nFile: osquery-rust/Cargo.toml\n```toml\n[dev-dependencies]\ntestcontainers = { version = \"0.23\", features = [\"blocking\"] }\n```\n\n### Step 2: Create integration test scaffold\nFile: osquery-rust/tests/integration_test.rs\n```rust\n//! Integration tests requiring Docker with osquery.\n//!\n//! These tests are separate from unit tests because they require:\n//! - Docker daemon running\n//! - Network access to pull osquery image\n//! - Real osquery thrift communication\n//!\n//! Run with: cargo test --test integration_test\n//! Skip with: cargo test --lib (unit tests only)\n\n#[cfg(test)]\n#[allow(clippy::expect_used, clippy::panic)] // Integration tests can panic on infra failures\nmod tests {\n    use testcontainers::{runners::SyncRunner, GenericImage, ImageExt};\n    use std::time::Duration;\n\n    const OSQUERY_IMAGE: \u0026str = \"osquery/osquery\";\n    const OSQUERY_TAG: \u0026str = \"5.12.1-ubuntu22.04\";\n    const STARTUP_TIMEOUT: Duration = Duration::from_secs(30);\n\n    /// Helper to create osquery container with extension socket exposed\n    fn create_osquery_container() -\u003e testcontainers::ContainerAsync\u003cGenericImage\u003e {\n        // TODO: Implement in Step 3\n        todo!()\n    }\n\n    #[test]\n    fn test_osquery_container_starts() {\n        // Verify container infrastructure works before adding real tests\n        let container = GenericImage::new(OSQUERY_IMAGE, OSQUERY_TAG)\n            .start()\n            .expect(\"Failed to start osquery container\");\n        \n        // Container started successfully\n        assert!(container.id().len() \u003e 0);\n    }\n}\n```\n\n### Step 3: Verify Docker setup works\n```bash\n# Pull image manually first to avoid timeout in tests\ndocker pull osquery/osquery:5.12.1-ubuntu22.04\n\n# Run scaffold test\ncargo test --test integration_test test_osquery_container_starts\n```\n\n## Success Criteria\n- [ ] testcontainers v0.23 added to dev-dependencies\n- [ ] osquery-rust/tests/integration_test.rs exists with module structure\n- [ ] `cargo test --test integration_test test_osquery_container_starts` passes\n- [ ] `cargo clippy --all-features --tests` passes\n- [ ] Pre-commit hooks pass\n\n## Key Considerations (SRE Review)\n\n**Docker Not Available:**\n- testcontainers will panic if Docker daemon not running\n- Tests should be in separate integration_test.rs so `cargo test --lib` skips them\n- CI must have Docker installed (GitHub Actions ubuntu-latest has it)\n\n**Image Pull Timeouts:**\n- First run may timeout pulling 500MB+ osquery image\n- CI should cache Docker layers or pre-pull image\n- Local dev: document `docker pull` step\n\n**Container Startup Time:**\n- osquery takes 5-10 seconds to initialize\n- Use wait_for conditions, not sleep\n- Set reasonable timeout (30s) to catch stuck containers\n\n**Testcontainers Version:**\n- v0.23 is latest stable (Dec 2024)\n- Blocking feature required for sync tests\n- Do NOT use async runner (adds tokio dependency complexity)\n\n## Anti-Patterns\n- ❌ NO hardcoded image:tag strings in tests (use constants)\n- ❌ NO sleep-based waits (use testcontainers wait_for)\n- ❌ NO unwrap in container setup (infrastructure failures should panic with message)\n- ❌ NO ignoring clippy in test code without justification","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T15:05:47.575113-05:00","updated_at":"2025-12-08T15:13:05.960197-05:00","closed_at":"2025-12-08T15:13:05.960197-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-x7l","depends_on_id":"osquery-rust-0r2","type":"parent-child","created_at":"2025-12-08T15:05:55.386074-05:00","created_by":"ryan"}]}
