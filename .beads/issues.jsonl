{"id":"osquery-rust-14q","content_hash":"fa08a8f4013f9eb0207103853dabd44bbb1417548f3ced4c942e45a8856ccd80","title":"Epic: Comprehensive Testing \u0026 Coverage Infrastructure","description":"","design":"## Requirements (IMMUTABLE)\n- All plugin traits (ReadOnlyTable, Table, LoggerPlugin, ConfigPlugin) have unit tests\n- Client communication is mockable via OsqueryClient trait abstraction\n- Server can be tested without real osquery sockets using mock client\n- TablePlugin enum dispatch is tested for all variants (Readonly, Writeable)\n- Code coverage is measured and reported in CI via cargo-llvm-cov\n- Coverage badge displays on main branch via dynamic-badges-action\n- All tests use mockall for auto-generated mocks where appropriate\n- Inline tests in modules using #[cfg(test)] (not separate tests/ directory)\n\n## Success Criteria (MUST ALL BE TRUE)\n- [ ] ReadOnlyTable trait has generate() and columns() tests\n- [ ] Table trait has insert/update/delete tests\n- [ ] TablePlugin enum dispatches correctly to both variants\n- [ ] OsqueryClient trait extracted from Client struct\n- [ ] Server testable with MockOsqueryClient (no real sockets)\n- [ ] Handler::handle_call() routing tested\n- [ ] LoggerPluginWrapper all request types tested\n- [ ] ConfigPlugin gen_config/gen_pack tested\n- [ ] ExtensionResponseEnum conversion tested\n- [ ] QueryConstraints parsing tested\n- [ ] mockall added as dev-dependency\n- [ ] GitHub Actions coverage workflow added\n- [ ] Coverage badge integration configured\n- [ ] Line coverage \u003e= 60% (up from ~15%)\n- [ ] All tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO tests in separate tests/ directory (consistency: inline #[cfg(test)] modules per CLAUDE.md)\n- ❌ NO mocking Thrift layer directly (complexity: use trait abstractions instead)\n- ❌ NO unwrap/expect/panic in test code (clippy: project forbids these)\n- ❌ NO skipping Server mockability (testing: core requirement for comprehensive coverage)\n- ❌ NO breaking public API (backwards compat: Client type alias must remain)\n- ❌ NO coverage workflow without badge (visibility: must show progress)\n\n## Approach\n1. Add mockall as dev-dependency for auto-generated mocks\n2. Extract OsqueryClient trait from Client, keeping Client as type alias for backwards compat\n3. Make Server generic over client type with default ThriftClient\n4. Add comprehensive unit tests inline in each module\n5. Add shared test utilities in test_utils.rs (cfg(test) only)\n6. Add GitHub Actions coverage workflow with dynamic badge\n\n## Architecture\n- client.rs: OsqueryClient trait + ThriftClient impl + MockOsqueryClient (test)\n- server.rs: Server\u003cP, C: OsqueryClient = ThriftClient\u003e + Handler tests\n- plugin/table/mod.rs: TablePlugin tests, ReadOnlyTable/Table trait tests\n- plugin/logger/mod.rs: Complete LoggerPluginWrapper tests\n- plugin/config/mod.rs: ConfigPlugin tests\n- plugin/_enums/response.rs: ExtensionResponseEnum conversion tests\n- test_utils.rs: Shared TestTable, TestConfig, mock socket utilities\n\n## Design Rationale\n### Problem\nCurrent test coverage ~15-20% covers only server shutdown and logger features.\nCore functionality (table plugins, client communication, request routing) untested.\nNo coverage metrics to track progress or regressions.\n\n### Research Findings\n**Codebase:**\n- server_tests.rs:41-367 - Socket mocking pattern using tempfile + UnixListener\n- plugin/logger/mod.rs:463-494 - TestLogger pattern implementing trait directly\n- client.rs:7-87 - Client struct uses concrete UnixStream, not mockable\n- server.rs:67-81 - Server struct could be made generic over client\n\n**External:**\n- cargo-llvm-cov - 2025 standard for Rust coverage, LLVM source-based instrumentation\n- mockall 0.13 - Most popular Rust mocking library, generates mocks from traits\n- dynamic-badges-action - GitHub Action for coverage badges via gists\n\n### Approaches Considered\n1. **Trait abstraction + mockall + inline tests** ✓\n   - Pros: Mockable client, auto-generated mocks, follows existing patterns\n   - Cons: Adds dependency, requires refactoring Client\n   - **Chosen because:** Enables comprehensive testing without real sockets\n\n2. **Keep concrete types, test via real sockets only**\n   - Pros: No refactoring, simpler\n   - Cons: Cannot test Server without osquery, limited coverage possible\n   - **Rejected because:** Cannot achieve comprehensive coverage goal\n\n3. **Separate tests/ directory with integration tests**\n   - Pros: Standard Rust convention\n   - Cons: Breaks project pattern (CLAUDE.md specifies inline tests)\n   - **Rejected because:** Inconsistent with established codebase convention\n\n### Scope Boundaries\n**In scope:**\n- Unit tests for all plugin traits\n- Client trait abstraction for mockability\n- Handler/Server integration tests with mocks\n- Coverage infrastructure (cargo-llvm-cov, GitHub Actions, badge)\n- mockall dev-dependency\n\n**Out of scope (deferred/never):**\n- Property-based testing (proptest) - deferred to future epic\n- Fuzzing infrastructure - deferred to future epic\n- Mutation testing - deferred to future epic\n- End-to-end tests with real osquery binary - separate epic\n- Benchmark infrastructure - separate epic\n\n### Open Questions\n- Should MockOsqueryClient be generated by mockall or hand-rolled? (lean mockall)\n- Coverage threshold for CI failure? (suggest warning at 50%, fail at 40%)\n- Include doc tests in coverage? (default yes)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-08T12:25:11.446669-05:00","updated_at":"2025-12-08T12:25:11.446669-05:00","source_repo":"."}
{"id":"osquery-rust-7bs","content_hash":"f6eb1a585ff838ace71c108700d111c450778dc01e04e4d9fef02f9b0e8eb382","title":"Task 1: Add mockall dependency and TablePlugin unit tests","description":"","design":"## Goal\nAdd mockall as dev-dependency and create comprehensive unit tests for TablePlugin enum dispatch and ReadOnlyTable/Table trait implementations. Tests must cover happy paths, error paths, and edge cases.\n\n## Effort Estimate\n6-8 hours\n\n## Study Existing Patterns\n- plugin/logger/mod.rs:463-494 - TestLogger pattern (struct with configurable state)\n- server_tests.rs - tempfile and assertion patterns\n- plugin/table/mod.rs:20-291 - TablePlugin enum, traits, result enums\n\n## Implementation\n\n### Step 1: Add mockall dependency\nFile: osquery-rust/Cargo.toml\n```toml\n[dev-dependencies]\ntempfile = \"^3.14\"\nmockall = \"0.13\"\n```\n\n### Step 2: Create TestReadOnlyTable mock\nFile: osquery-rust/src/plugin/table/mod.rs (at bottom, inside #[cfg(test)])\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::_osquery::osquery;\n\n    struct TestReadOnlyTable {\n        test_name: String,\n        test_columns: Vec\u003cColumnDef\u003e,\n        test_rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e,\n    }\n\n    impl TestReadOnlyTable {\n        fn new(name: \u0026str) -\u003e Self {\n            Self {\n                test_name: name.to_string(),\n                test_columns: vec![\n                    ColumnDef::new(\"id\", ColumnType::Integer),\n                    ColumnDef::new(\"value\", ColumnType::Text),\n                ],\n                test_rows: vec![],\n            }\n        }\n\n        fn with_rows(mut self, rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e) -\u003e Self {\n            self.test_rows = rows;\n            self\n        }\n    }\n\n    impl ReadOnlyTable for TestReadOnlyTable {\n        fn name(\u0026self) -\u003e String { self.test_name.clone() }\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { self.test_columns.clone() }\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            ExtensionResponse::new(\n                osquery::ExtensionStatus {\n                    code: Some(0),\n                    message: Some(\"OK\".to_string()),\n                    uuid: None,\n                },\n                self.test_rows.clone(),\n            )\n        }\n        fn shutdown(\u0026self) {}\n    }\n}\n```\n\n### Step 3: Create TestWriteableTable mock\n```rust\n    struct TestWriteableTable {\n        test_name: String,\n        test_columns: Vec\u003cColumnDef\u003e,\n        data: BTreeMap\u003cu64, BTreeMap\u003cString, String\u003e\u003e,\n        next_id: u64,\n    }\n\n    impl TestWriteableTable {\n        fn new(name: \u0026str) -\u003e Self {\n            Self {\n                test_name: name.to_string(),\n                test_columns: vec![\n                    ColumnDef::new(\"id\", ColumnType::Integer),\n                    ColumnDef::new(\"value\", ColumnType::Text),\n                ],\n                data: BTreeMap::new(),\n                next_id: 1,\n            }\n        }\n    }\n\n    impl Table for TestWriteableTable {\n        fn name(\u0026self) -\u003e String { self.test_name.clone() }\n        fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { self.test_columns.clone() }\n        fn generate(\u0026self, _req: ExtensionPluginRequest) -\u003e ExtensionResponse {\n            let rows: Vec\u003cBTreeMap\u003cString, String\u003e\u003e = self.data.values().cloned().collect();\n            ExtensionResponse::new(\n                osquery::ExtensionStatus { code: Some(0), message: Some(\"OK\".to_string()), uuid: None },\n                rows,\n            )\n        }\n        fn update(\u0026mut self, rowid: u64, row: \u0026serde_json::Value) -\u003e UpdateResult {\n            if self.data.contains_key(\u0026rowid) {\n                let mut r = BTreeMap::new();\n                if let Some(val) = row.get(1).and_then(|v| v.as_str()) {\n                    r.insert(\"value\".to_string(), val.to_string());\n                }\n                self.data.insert(rowid, r);\n                UpdateResult::Success\n            } else {\n                UpdateResult::Err(\"Row not found\".to_string())\n            }\n        }\n        fn delete(\u0026mut self, rowid: u64) -\u003e DeleteResult {\n            if self.data.remove(\u0026rowid).is_some() {\n                DeleteResult::Success\n            } else {\n                DeleteResult::Err(\"Row not found\".to_string())\n            }\n        }\n        fn insert(\u0026mut self, auto_rowid: bool, row: \u0026serde_json::Value) -\u003e InsertResult {\n            let id = if auto_rowid { self.next_id } else {\n                row.get(0).and_then(|v| v.as_u64()).unwrap_or(self.next_id)\n            };\n            let mut r = BTreeMap::new();\n            r.insert(\"id\".to_string(), id.to_string());\n            if let Some(val) = row.get(1).and_then(|v| v.as_str()) {\n                r.insert(\"value\".to_string(), val.to_string());\n            }\n            self.data.insert(id, r);\n            self.next_id = id + 1;\n            InsertResult::Success(id)\n        }\n        fn shutdown(\u0026self) {}\n    }\n```\n\n### Step 4: Implement tests\n\n```rust\n    // --- ReadOnlyTable tests ---\n\n    #[test]\n    fn test_readonly_table_plugin_name() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        assert_eq!(plugin.name(), \"test_table\");\n    }\n\n    #[test]\n    fn test_readonly_table_plugin_columns() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        let routes = plugin.routes();\n        assert_eq!(routes.len(), 2); // id and value columns\n        assert_eq!(routes[0].get(\"name\"), Some(\u0026\"id\".to_string()));\n        assert_eq!(routes[1].get(\"name\"), Some(\u0026\"value\".to_string()));\n    }\n\n    #[test]\n    fn test_readonly_table_plugin_generate() {\n        let mut row = BTreeMap::new();\n        row.insert(\"id\".to_string(), \"1\".to_string());\n        row.insert(\"value\".to_string(), \"test\".to_string());\n        let table = TestReadOnlyTable::new(\"test_table\").with_rows(vec![row]);\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"generate\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0));\n        assert_eq!(response.response.len(), 1);\n    }\n\n    #[test]\n    fn test_readonly_table_routes_via_handle_call() {\n        let table = TestReadOnlyTable::new(\"test_table\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"columns\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0));\n        assert_eq!(response.response.len(), 2); // 2 columns\n    }\n\n    // --- Writeable table tests ---\n\n    #[test]\n    fn test_writeable_table_insert() {\n        let table = TestWriteableTable::new(\"test_table\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        req.insert(\"auto_rowid\".to_string(), \"true\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[null, \\\"test_value\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    #[test]\n    fn test_writeable_table_update() {\n        let mut table = TestWriteableTable::new(\"test_table\");\n        // Pre-insert a row\n        table.insert(true, \u0026serde_json::json!([null, \"initial\"]));\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"updated\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    #[test]\n    fn test_writeable_table_delete() {\n        let mut table = TestWriteableTable::new(\"test_table\");\n        table.insert(true, \u0026serde_json::json!([null, \"to_delete\"]));\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(0)); // Success\n    }\n\n    // --- Dispatch tests ---\n\n    #[test]\n    fn test_table_plugin_dispatch_readonly() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        assert!(matches!(plugin, TablePlugin::Readonly(_)));\n        assert_eq!(plugin.registry(), Registry::Table);\n    }\n\n    #[test]\n    fn test_table_plugin_dispatch_writeable() {\n        let table = TestWriteableTable::new(\"writeable\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        assert!(matches!(plugin, TablePlugin::Writeable(_)));\n        assert_eq!(plugin.registry(), Registry::Table);\n    }\n\n    // --- Error path tests ---\n\n    #[test]\n    fn test_readonly_table_insert_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        // Readonly error returns code 2 (see ExtensionResponseEnum::Readonly)\n        assert_eq!(response.status.code, Some(2));\n    }\n\n    #[test]\n    fn test_readonly_table_update_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(2)); // Readonly error\n    }\n\n    #[test]\n    fn test_readonly_table_delete_returns_readonly_error() {\n        let table = TestReadOnlyTable::new(\"readonly\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(2)); // Readonly error\n    }\n\n    #[test]\n    fn test_invalid_action_returns_error() {\n        let table = TestReadOnlyTable::new(\"test\");\n        let plugin = TablePlugin::from_readonly_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"invalid_action\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n\n    #[test]\n    fn test_update_with_invalid_id_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"not_a_number\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"[1, \\\"test\\\"]\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure - cannot parse id\n    }\n\n    #[test]\n    fn test_update_with_invalid_json_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"update\".to_string());\n        req.insert(\"id\".to_string(), \"1\".to_string());\n        req.insert(\"json_value_array\".to_string(), \"not valid json\".to_string());\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure - invalid JSON\n    }\n\n    #[test]\n    fn test_insert_with_missing_json_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"insert\".to_string());\n        // Missing json_value_array\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n\n    #[test]\n    fn test_delete_with_missing_id_returns_error() {\n        let table = TestWriteableTable::new(\"test\");\n        let plugin = TablePlugin::from_writeable_table(table);\n        \n        let mut req = BTreeMap::new();\n        req.insert(\"action\".to_string(), \"delete\".to_string());\n        // Missing id\n        let response = plugin.handle_call(req);\n        \n        assert_eq!(response.status.code, Some(1)); // Failure\n    }\n```\n\n## Implementation Checklist\n- [ ] osquery-rust/Cargo.toml:47-48 - add mockall = \"0.13\" to [dev-dependencies]\n- [ ] osquery-rust/src/plugin/table/mod.rs:292+ - add #[cfg(test)] mod tests\n- [ ] mod tests - TestReadOnlyTable struct with new(), with_rows() builder\n- [ ] mod tests - TestWriteableTable struct with CRUD state\n- [ ] mod tests - test_readonly_table_plugin_name() verifies name()\n- [ ] mod tests - test_readonly_table_plugin_columns() verifies routes() returns 2 columns\n- [ ] mod tests - test_readonly_table_plugin_generate() verifies generate returns rows\n- [ ] mod tests - test_readonly_table_routes_via_handle_call() verifies columns action\n- [ ] mod tests - test_writeable_table_insert() verifies insert returns success\n- [ ] mod tests - test_writeable_table_update() verifies update returns success\n- [ ] mod tests - test_writeable_table_delete() verifies delete returns success\n- [ ] mod tests - test_table_plugin_dispatch_readonly() verifies enum variant\n- [ ] mod tests - test_table_plugin_dispatch_writeable() verifies enum variant\n- [ ] mod tests - test_readonly_table_insert_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_readonly_table_update_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_readonly_table_delete_returns_readonly_error() verifies code 2\n- [ ] mod tests - test_invalid_action_returns_error() verifies code 1\n- [ ] mod tests - test_update_with_invalid_id_returns_error() verifies code 1\n- [ ] mod tests - test_update_with_invalid_json_returns_error() verifies code 1\n- [ ] mod tests - test_insert_with_missing_json_returns_error() verifies code 1\n- [ ] mod tests - test_delete_with_missing_id_returns_error() verifies code 1\n\n## Success Criteria\n- [ ] mockall = \"0.13\" added to [dev-dependencies] in Cargo.toml\n- [ ] 20 table plugin tests implemented and passing\n- [ ] Tests cover: name(), columns(), generate(), insert(), update(), delete()\n- [ ] Tests cover: TablePlugin::Readonly and TablePlugin::Writeable dispatch\n- [ ] Tests cover: readonly error (code 2) for write ops on ReadOnlyTable\n- [ ] Tests cover: failure (code 1) for invalid action, bad id, bad JSON, missing params\n- [ ] cargo test --all-features passes with 0 failures\n- [ ] cargo clippy --all-features passes with 0 warnings\n- [ ] .git/hooks/pre-commit passes\n\n## Key Considerations (SRE REVIEW)\n\n**Edge Case: Empty columns/rows**\n- TestReadOnlyTable with empty columns should return empty routes\n- generate() with no rows should return success with empty response array\n- Both are valid states, not errors\n\n**Edge Case: Mutex poisoning**\n- If panic occurs while holding Mutex lock, subsequent lock() calls return Err\n- Code handles this gracefully (returns \"unable-to-get-table-name\" or Failure response)\n- Tests do NOT need to verify mutex poisoning (requires unsafe code to trigger)\n- Document that mutex poisoning is handled but not directly tested\n\n**Edge Case: Invalid JSON parsing**\n- json_value_array with malformed JSON must return Failure (code 1)\n- Empty string \"\" is invalid JSON, should return error\n- Tests verify: \"not valid json\" returns error\n\n**Edge Case: Non-numeric id**\n- update/delete with id=\"not_a_number\" must return Failure (code 1)\n- Tests verify this path explicitly\n\n**Reference Implementation**\n- plugin/logger/mod.rs:463-494 shows TestLogger pattern\n- server_tests.rs shows assertion patterns without unwrap\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO unwrap() or expect() in test code (use assert_eq! or pattern matching)\n- ❌ NO panic!() or todo!() stubs\n- ❌ NO placeholder comments like \"// TODO\"\n- ❌ NO testing Mutex poisoning (requires unsafe, out of scope)\n- ❌ NO using mockall for these tests (hand-rolled mocks are clearer here)","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-08T12:25:29.599561-05:00","updated_at":"2025-12-08T12:33:34.953114-05:00","closed_at":"2025-12-08T12:33:34.953114-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-7bs","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T12:25:34.786923-05:00","created_by":"ryan"}]}
{"id":"osquery-rust-jn9","content_hash":"8f37e05585312e4476972511e0e71c836174cf60d087f9bfdfe83ba9777e091a","title":"Task 2: Extract OsqueryClient trait and add Server tests","description":"","design":"## Goal\nExtract OsqueryClient trait from Client struct to enable mocking osquery daemon in tests. Then add Server tests that use MockOsqueryClient.\n\n## Context\nCompleted osquery-rust-7bs: Added mockall, 23 table plugin tests. \nNow need to make Server testable without real osquery daemon.\n\n## Effort Estimate\n6-8 hours\n\n## Study Existing Patterns\n- client.rs:7-87 - Current Client struct with concrete UnixStream\n- server.rs:67-414 - Server struct uses Client directly\n- server_tests.rs - Existing socket mock patterns\n- Current Client implements TExtensionManagerSyncClient and TExtensionSyncClient traits\n\n## Implementation\n\n### Step 1: Extract OsqueryClient trait from Client\nFile: osquery-rust/src/client.rs\n\nThe trait should match the methods Server actually uses. Looking at server.rs, Server uses:\n- register_extension() (via TExtensionManagerSyncClient)\n- deregister_extension() (via TExtensionManagerSyncClient)  \n- ping() (via TExtensionSyncClient)\n\nCreate custom trait with these methods:\n```rust\nuse crate::_osquery::{ExtensionRegistry, ExtensionRouteUUID, ExtensionStatus, InternalExtensionInfo};\n\n/// Trait for osquery daemon communication - enables mocking in tests\npub trait OsqueryClient: Send {\n    fn register_extension(\n        \u0026mut self,\n        info: InternalExtensionInfo,\n        registry: ExtensionRegistry,\n    ) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n    \n    fn deregister_extension(\u0026mut self, uuid: ExtensionRouteUUID) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n    \n    fn ping(\u0026mut self) -\u003e thrift::Result\u003cExtensionStatus\u003e;\n}\n```\n\nNOTE: Use thrift::Result\u003cT\u003e not Result\u003cT, Error\u003e to match existing return types.\n\n### Step 2: Rename Client to ThriftClient, implement trait\n```rust\n/// Production implementation using Thrift over Unix sockets\npub struct ThriftClient {\n    client: osquery::ExtensionManagerSyncClient\u003c\n        TBinaryInputProtocol\u003cUnixStream\u003e,\n        TBinaryOutputProtocol\u003cUnixStream\u003e,\n    \u003e,\n}\n\nimpl ThriftClient {\n    pub fn new(socket_path: \u0026str, timeout: Duration) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        let socket_tx = UnixStream::connect(socket_path)?;\n        let socket_rx = socket_tx.try_clone()?;\n        let in_proto = TBinaryInputProtocol::new(socket_tx, true);\n        let out_proto = TBinaryOutputProtocol::new(socket_rx, true);\n        Ok(ThriftClient {\n            client: osquery::ExtensionManagerSyncClient::new(in_proto, out_proto),\n        })\n    }\n}\n\nimpl OsqueryClient for ThriftClient {\n    fn register_extension(\u0026mut self, info: InternalExtensionInfo, registry: ExtensionRegistry) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionManagerSyncClient::register_extension(\u0026mut self.client, info, registry)\n    }\n    \n    fn deregister_extension(\u0026mut self, uuid: ExtensionRouteUUID) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionManagerSyncClient::deregister_extension(\u0026mut self.client, uuid)\n    }\n    \n    fn ping(\u0026mut self) -\u003e thrift::Result\u003cExtensionStatus\u003e {\n        osquery::TExtensionSyncClient::ping(\u0026mut self.client)\n    }\n}\n\n// Backwards compatibility - CRITICAL\npub type Client = ThriftClient;\n```\n\n### Step 3: Keep existing TExtension*SyncClient impls\nKeep the existing impls of TExtensionManagerSyncClient and TExtensionSyncClient for ThriftClient - they may be used elsewhere.\n\n### Step 4: Update Server to be generic over client type\nFile: osquery-rust/src/server.rs\n\n```rust\npub struct Server\u003cP: OsqueryPlugin + Clone + Send + Sync + 'static, C: OsqueryClient = ThriftClient\u003e {\n    name: String,\n    socket_path: String,\n    client: C,\n    plugins: Vec\u003cP\u003e,\n    // ... rest unchanged\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static, C: OsqueryClient\u003e Server\u003cP, C\u003e {\n    // Existing new() becomes specific to ThriftClient\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static\u003e Server\u003cP, ThriftClient\u003e {\n    pub fn new(name: Option\u003c\u0026str\u003e, socket_path: \u0026str) -\u003e Result\u003cSelf, std::io::Error\u003e {\n        // ... existing implementation\n    }\n}\n\nimpl\u003cP: OsqueryPlugin + Clone + Send + 'static, C: OsqueryClient\u003e Server\u003cP, C\u003e {\n    /// Constructor for testing with mock client\n    pub fn with_client(name: Option\u003c\u0026str\u003e, socket_path: \u0026str, client: C) -\u003e Self {\n        Server {\n            name: name.unwrap_or(clap::crate_name!()).to_string(),\n            socket_path: socket_path.to_string(),\n            client,\n            plugins: Vec::new(),\n            ping_interval: DEFAULT_PING_INTERVAL,\n            uuid: None,\n            started: false,\n            shutdown_flag: Arc::new(AtomicBool::new(false)),\n            listener_thread: None,\n            listen_path: None,\n        }\n    }\n}\n```\n\n### Step 5: Add MockOsqueryClient and Server tests\nFile: osquery-rust/src/server.rs (add to existing #[cfg(test)] section or create new)\n\n```rust\n#[cfg(test)]\nmod client_mock_tests {\n    use super::*;\n    use crate::client::OsqueryClient;\n    use mockall::mock;\n    \n    mock! {\n        pub TestClient {}\n        impl OsqueryClient for TestClient {\n            fn register_extension(\n                \u0026mut self,\n                info: osquery::InternalExtensionInfo,\n                registry: osquery::ExtensionRegistry,\n            ) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n            \n            fn deregister_extension(\u0026mut self, uuid: osquery::ExtensionRouteUUID) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n            \n            fn ping(\u0026mut self) -\u003e thrift::Result\u003cosquery::ExtensionStatus\u003e;\n        }\n    }\n    \n    #[test]\n    fn test_server_with_mock_client_creation() {\n        let mock_client = MockTestClient::new();\n        let server: Server\u003cPlugin, MockTestClient\u003e = Server::with_client(\n            Some(\"test_ext\"),\n            \"/tmp/test.sock\",\n            mock_client,\n        );\n        assert_eq!(server.name, \"test_ext\");\n    }\n    \n    #[test]\n    fn test_server_register_plugin() {\n        use crate::plugin::table::{TablePlugin, ReadOnlyTable, ColumnDef, ColumnType};\n        use crate::plugin::table::column_def::ColumnOptions;\n        \n        // Create simple test table\n        struct TestTable;\n        impl ReadOnlyTable for TestTable {\n            fn name(\u0026self) -\u003e String { \"test\".to_string() }\n            fn columns(\u0026self) -\u003e Vec\u003cColumnDef\u003e { \n                vec![ColumnDef::new(\"col\", ColumnType::Text, ColumnOptions::DEFAULT)]\n            }\n            fn generate(\u0026self, _: crate::ExtensionPluginRequest) -\u003e crate::ExtensionResponse {\n                crate::ExtensionResponse::new(osquery::ExtensionStatus::default(), vec![])\n            }\n            fn shutdown(\u0026self) {}\n        }\n        \n        let mock_client = MockTestClient::new();\n        let mut server: Server\u003cPlugin, MockTestClient\u003e = Server::with_client(\n            Some(\"test\"),\n            \"/tmp/test.sock\",\n            mock_client,\n        );\n        \n        let plugin = Plugin::table(TestTable);\n        server.register_plugin(plugin);\n        assert_eq!(server.plugins.len(), 1);\n    }\n}\n```\n\n## Implementation Checklist\n- [ ] client.rs:1-10 - Add OsqueryClient trait definition\n- [ ] client.rs:7-12 - Rename struct Client to ThriftClient\n- [ ] client.rs:14-27 - Update impl block to impl ThriftClient (keep same new() signature)\n- [ ] client.rs - Add impl OsqueryClient for ThriftClient\n- [ ] client.rs - Add type alias: pub type Client = ThriftClient;\n- [ ] client.rs - Keep existing TExtension*SyncClient impls for ThriftClient\n- [ ] lib.rs - Export OsqueryClient trait: pub use client::OsqueryClient;\n- [ ] server.rs:67 - Update Server struct: Server\u003cP, C: OsqueryClient = ThriftClient\u003e\n- [ ] server.rs:83 - Split impl blocks: one for Server\u003cP, ThriftClient\u003e, one generic\n- [ ] server.rs - Add Server::with_client() constructor\n- [ ] server.rs - Update all methods to use C instead of Client where needed\n- [ ] server.rs tests - Add MockTestClient using mockall::mock!\n- [ ] server.rs tests - test_server_with_mock_client_creation()\n- [ ] server.rs tests - test_server_register_plugin()\n- [ ] Verify cargo test --all-features passes\n- [ ] Verify pre-commit hooks pass\n\n## Success Criteria\n- [ ] OsqueryClient trait defined in client.rs with register_extension, deregister_extension, ping\n- [ ] ThriftClient struct (renamed from Client) implements OsqueryClient\n- [ ] pub type Client = ThriftClient; exists for backwards compat\n- [ ] Server\u003cP, C: OsqueryClient = ThriftClient\u003e compiles\n- [ ] Server::with_client() allows injecting mock client\n- [ ] MockTestClient generated via mockall::mock!\n- [ ] 2+ Server tests with mock client passing\n- [ ] Existing server_tests.rs (5 tests) still pass\n- [ ] All 38+ tests pass: cargo test --all-features\n- [ ] Pre-commit hooks pass (clippy, fmt)\n\n## Key Considerations (SRE REVIEW)\n\n**Error Type Compatibility:**\n- OsqueryClient trait returns thrift::Result\u003cT\u003e, NOT std::io::Error\n- This matches existing TExtension*SyncClient trait signatures\n- Server::new() returns Result\u003c_, std::io::Error\u003e (unchanged)\n- Server::with_client() returns Self directly (no Result - client already constructed)\n\n**Backwards Compatibility:**\n- Client type alias MUST exist: pub type Client = ThriftClient;\n- Client::new() signature MUST remain: fn new(socket_path: \u0026str, timeout: Duration) -\u003e Result\u003cSelf, std::io::Error\u003e\n- Server::new() MUST continue to work unchanged\n- Existing server_tests.rs MUST pass unchanged\n\n**Thread Safety:**\n- OsqueryClient requires Send (client moves to server thread)\n- ThriftClient is Send because UnixStream is Send\n- MockTestClient from mockall is Send by default\n\n**Generic Type Propagation:**\n- Server\u003cP\u003e becomes Server\u003cP, C = ThriftClient\u003e\n- Handler\u003cP\u003e may need C generic if it accesses client directly\n- Check all impl blocks and update type parameters\n\n**Edge Case: Existing todo!() in client.rs:**\n- client.rs:80 has todo!() in call() method\n- This is in TExtensionSyncClient impl, NOT OsqueryClient trait\n- OsqueryClient only exposes register_extension, deregister_extension, ping\n- todo!() remains but is never called through our trait (safe to leave)\n\n## Anti-Patterns (FORBIDDEN)\n- ❌ NO breaking Client::new() API signature\n- ❌ NO changing Client::new() return type\n- ❌ NO unwrap/expect in test or production code\n- ❌ NO removing existing server_tests.rs tests\n- ❌ NO removing TExtension*SyncClient impls (may be used elsewhere)\n- ❌ NO using std::io::Error where thrift::Result expected","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-08T12:34:12.282838-05:00","updated_at":"2025-12-08T12:35:38.738474-05:00","source_repo":".","dependencies":[{"issue_id":"osquery-rust-jn9","depends_on_id":"osquery-rust-14q","type":"parent-child","created_at":"2025-12-08T12:34:19.760684-05:00","created_by":"ryan"},{"issue_id":"osquery-rust-jn9","depends_on_id":"osquery-rust-7bs","type":"blocks","created_at":"2025-12-08T12:34:20.300833-05:00","created_by":"ryan"}]}
